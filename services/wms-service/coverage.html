
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/erp-cosmetics/wms-service/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/erp-cosmetics/wms-service/internal/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/erp-cosmetics/wms-service/internal/delivery/grpc/server.go (0.0%)</option>
				
				<option value="file3">github.com/erp-cosmetics/wms-service/internal/delivery/http/handler/grn_handler.go (0.0%)</option>
				
				<option value="file4">github.com/erp-cosmetics/wms-service/internal/delivery/http/handler/health_handler.go (0.0%)</option>
				
				<option value="file5">github.com/erp-cosmetics/wms-service/internal/delivery/http/handler/inventory_count_handler.go (0.0%)</option>
				
				<option value="file6">github.com/erp-cosmetics/wms-service/internal/delivery/http/handler/issue_handler.go (0.0%)</option>
				
				<option value="file7">github.com/erp-cosmetics/wms-service/internal/delivery/http/handler/reservation_handler.go (0.0%)</option>
				
				<option value="file8">github.com/erp-cosmetics/wms-service/internal/delivery/http/handler/warehouse_handler.go (0.0%)</option>
				
				<option value="file9">github.com/erp-cosmetics/wms-service/internal/delivery/http/router/router.go (0.0%)</option>
				
				<option value="file10">github.com/erp-cosmetics/wms-service/internal/domain/entity/goods_issue.go (50.0%)</option>
				
				<option value="file11">github.com/erp-cosmetics/wms-service/internal/domain/entity/grn.go (81.8%)</option>
				
				<option value="file12">github.com/erp-cosmetics/wms-service/internal/domain/entity/inventory_count.go (83.3%)</option>
				
				<option value="file13">github.com/erp-cosmetics/wms-service/internal/domain/entity/location.go (0.0%)</option>
				
				<option value="file14">github.com/erp-cosmetics/wms-service/internal/domain/entity/lot.go (60.0%)</option>
				
				<option value="file15">github.com/erp-cosmetics/wms-service/internal/domain/entity/stock.go (95.7%)</option>
				
				<option value="file16">github.com/erp-cosmetics/wms-service/internal/domain/entity/stock_fefo.go (75.9%)</option>
				
				<option value="file17">github.com/erp-cosmetics/wms-service/internal/domain/entity/stock_movement.go (75.0%)</option>
				
				<option value="file18">github.com/erp-cosmetics/wms-service/internal/domain/entity/stock_reservation.go (83.3%)</option>
				
				<option value="file19">github.com/erp-cosmetics/wms-service/internal/domain/entity/warehouse.go (0.0%)</option>
				
				<option value="file20">github.com/erp-cosmetics/wms-service/internal/infrastructure/event/publisher.go (0.0%)</option>
				
				<option value="file21">github.com/erp-cosmetics/wms-service/internal/infrastructure/persistence/postgres/grn_repo.go (0.0%)</option>
				
				<option value="file22">github.com/erp-cosmetics/wms-service/internal/infrastructure/persistence/postgres/inventory_count_repo.go (0.0%)</option>
				
				<option value="file23">github.com/erp-cosmetics/wms-service/internal/infrastructure/persistence/postgres/lot_repo.go (0.0%)</option>
				
				<option value="file24">github.com/erp-cosmetics/wms-service/internal/infrastructure/persistence/postgres/stock_repo.go (0.0%)</option>
				
				<option value="file25">github.com/erp-cosmetics/wms-service/internal/infrastructure/persistence/postgres/warehouse_repo.go (0.0%)</option>
				
				<option value="file26">github.com/erp-cosmetics/wms-service/internal/infrastructure/scheduler/scheduler.go (0.0%)</option>
				
				<option value="file27">github.com/erp-cosmetics/wms-service/internal/infrastructure/subscriber/subscriber.go (0.0%)</option>
				
				<option value="file28">github.com/erp-cosmetics/wms-service/internal/testmocks/mocks.go (0.0%)</option>
				
				<option value="file29">github.com/erp-cosmetics/wms-service/internal/testutils/builders.go (0.0%)</option>
				
				<option value="file30">github.com/erp-cosmetics/wms-service/internal/usecase/adjustment/adjustment_usecase.go (0.0%)</option>
				
				<option value="file31">github.com/erp-cosmetics/wms-service/internal/usecase/grn/grn_usecase.go (73.4%)</option>
				
				<option value="file32">github.com/erp-cosmetics/wms-service/internal/usecase/inventory/inventory_usecase.go (0.0%)</option>
				
				<option value="file33">github.com/erp-cosmetics/wms-service/internal/usecase/issue/issue_usecase.go (78.4%)</option>
				
				<option value="file34">github.com/erp-cosmetics/wms-service/internal/usecase/lot/lot_usecase.go (0.0%)</option>
				
				<option value="file35">github.com/erp-cosmetics/wms-service/internal/usecase/reservation/reservation_usecase.go (50.0%)</option>
				
				<option value="file36">github.com/erp-cosmetics/wms-service/internal/usecase/stock/stock_usecase.go (0.0%)</option>
				
				<option value="file37">github.com/erp-cosmetics/wms-service/internal/usecase/warehouse/warehouse_usecase.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/config"
        wmsgrpc "github.com/erp-cosmetics/wms-service/internal/delivery/grpc"
        "github.com/erp-cosmetics/wms-service/internal/delivery/http/handler"
        "github.com/erp-cosmetics/wms-service/internal/delivery/http/router"
        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/infrastructure/event"
        "github.com/erp-cosmetics/wms-service/internal/infrastructure/persistence/postgres"
        "github.com/erp-cosmetics/wms-service/internal/infrastructure/scheduler"
        "github.com/erp-cosmetics/wms-service/internal/infrastructure/subscriber"
        adjustment_uc "github.com/erp-cosmetics/wms-service/internal/usecase/adjustment"
        grn_uc "github.com/erp-cosmetics/wms-service/internal/usecase/grn"
        inventory_uc "github.com/erp-cosmetics/wms-service/internal/usecase/inventory"
        issue_uc "github.com/erp-cosmetics/wms-service/internal/usecase/issue"
        lot_uc "github.com/erp-cosmetics/wms-service/internal/usecase/lot"
        reservation_uc "github.com/erp-cosmetics/wms-service/internal/usecase/reservation"
        stock_uc "github.com/erp-cosmetics/wms-service/internal/usecase/stock"
        warehouse_uc "github.com/erp-cosmetics/wms-service/internal/usecase/warehouse"
        "github.com/erp-cosmetics/shared/pkg/database"
        "github.com/erp-cosmetics/shared/pkg/logger"
        natspkg "github.com/erp-cosmetics/shared/pkg/nats"
        natslib "github.com/nats-io/nats.go"
        "go.uber.org/zap"
        "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to load config: %v", err))</span>
        }

        // Initialize logger
        <span class="cov0" title="0">log, err := logger.NewLogger(cfg.ServiceName, &amp;logger.Config{
                Level:  cfg.LogLevel,
                Format: cfg.LogFormat,
        })
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to init logger: %v", err))</span>
        }
        <span class="cov0" title="0">defer logger.Sync()

        log.Info("Starting WMS Service",
                zap.String("service", cfg.ServiceName),
                zap.String("port", cfg.Port),
        )

        // Connect to PostgreSQL
        db, err := database.Connect(database.NewDefaultConfig(cfg.GetDSN()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to connect to database", zap.Error(err))
        }</span>
        <span class="cov0" title="0">log.Info("Connected to PostgreSQL")

        // Auto-migrate entities
        err = db.AutoMigrate(
                &amp;entity.Warehouse{},
                &amp;entity.Zone{},
                &amp;entity.Location{},
                &amp;entity.Lot{},
                &amp;entity.Stock{},
                &amp;entity.StockMovement{},
                &amp;entity.StockReservation{},
                &amp;entity.GRN{},
                &amp;entity.GRNLineItem{},
                &amp;entity.GoodsIssue{},
                &amp;entity.GILineItem{},
                &amp;entity.InventoryCount{},
                &amp;entity.InventoryCountLineItem{},
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Warn("Auto-migration warning", zap.Error(err))
        }</span>

        // Connect to NATS
        <span class="cov0" title="0">natsClient, err := natspkg.NewClient(&amp;natspkg.Config{
                URL: cfg.NATSUrl,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Warn("Failed to connect to NATS, events will not be published", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                log.Info("Connected to NATS")
        }</span>

        // Initialize repositories
        <span class="cov0" title="0">warehouseRepo := postgres.NewWarehouseRepository(db)
        zoneRepo := postgres.NewZoneRepository(db)
        locationRepo := postgres.NewLocationRepository(db)
        lotRepo := postgres.NewLotRepository(db)
        stockRepo := postgres.NewStockRepository(db)
        grnRepo := postgres.NewGRNRepository(db)
        issueRepo := postgres.NewGoodsIssueRepository(db)
        inventoryCountRepo := postgres.NewInventoryCountRepository(db)

        // Initialize event publisher
        eventPub := event.NewPublisher(natsClient, log)

        // Initialize warehouse use cases
        listWarehousesUC := warehouse_uc.NewListWarehousesUseCase(warehouseRepo)
        getWarehouseUC := warehouse_uc.NewGetWarehouseUseCase(warehouseRepo)
        getZonesUC := warehouse_uc.NewGetZonesUseCase(zoneRepo)
        getLocationsUC := warehouse_uc.NewGetLocationsUseCase(locationRepo)

        // Initialize stock use cases
        getStockUC := stock_uc.NewGetStockUseCase(stockRepo)
        issueStockFEFOUC := stock_uc.NewIssueStockFEFOUseCase(stockRepo, eventPub)
        reserveStockUC := stock_uc.NewReserveStockUseCase(stockRepo, eventPub)
        releaseReservationUC := stock_uc.NewReleaseReservationUseCase(stockRepo)

        // Initialize lot use cases
        getLotUC := lot_uc.NewGetLotUseCase(lotRepo)
        listLotsUC := lot_uc.NewListLotsUseCase(lotRepo)
        getExpiringLotsUC := lot_uc.NewGetExpiringLotsUseCase(lotRepo)
        getLotMovementsUC := lot_uc.NewGetLotMovementsUseCase(stockRepo)

        // Initialize GRN use cases
        createGRNUC := grn_uc.NewCreateGRNUseCase(grnRepo, lotRepo, stockRepo, zoneRepo, locationRepo, eventPub)
        completeGRNUC := grn_uc.NewCompleteGRNUseCase(grnRepo, lotRepo, stockRepo, zoneRepo, eventPub)
        getGRNUC := grn_uc.NewGetGRNUseCase(grnRepo)
        listGRNsUC := grn_uc.NewListGRNsUseCase(grnRepo)

        // Initialize Goods Issue use cases
        createIssueUC := issue_uc.NewCreateGoodsIssueUseCase(issueRepo, stockRepo, eventPub)
        getIssueUC := issue_uc.NewGetGoodsIssueUseCase(issueRepo)
        listIssuesUC := issue_uc.NewListGoodsIssuesUseCase(issueRepo)

        // Initialize Reservation use cases
        createReservationUC := reservation_uc.NewCreateReservationUseCase(stockRepo, eventPub)
        releaseReservationUC2 := reservation_uc.NewReleaseReservationUseCase(stockRepo)
        checkAvailabilityUC := reservation_uc.NewCheckAvailabilityUseCase(stockRepo)

        // Initialize Adjustment use cases
        createAdjustmentUC := adjustment_uc.NewCreateAdjustmentUseCase(stockRepo)
        transferStockUC := adjustment_uc.NewTransferStockUseCase(stockRepo)

        // Initialize Inventory Count use cases
        createInventoryCountUC := inventory_uc.NewCreateInventoryCountUseCase(inventoryCountRepo, stockRepo, locationRepo)
        startInventoryCountUC := inventory_uc.NewStartInventoryCountUseCase(inventoryCountRepo)
        recordCountUC := inventory_uc.NewRecordCountUseCase(inventoryCountRepo)
        completeInventoryCountUC := inventory_uc.NewCompleteInventoryCountUseCase(inventoryCountRepo, stockRepo)
        getInventoryCountUC := inventory_uc.NewGetInventoryCountUseCase(inventoryCountRepo)
        listInventoryCountsUC := inventory_uc.NewListInventoryCountsUseCase(inventoryCountRepo)

        // Initialize handlers
        warehouseHandler := handler.NewWarehouseHandler(listWarehousesUC, getWarehouseUC, getZonesUC, getLocationsUC)
        stockHandler := handler.NewStockHandler(getStockUC, issueStockFEFOUC, reserveStockUC, releaseReservationUC)
        lotHandler := handler.NewLotHandler(getLotUC, listLotsUC, getExpiringLotsUC, getLotMovementsUC)
        grnHandler := handler.NewGRNHandler(createGRNUC, completeGRNUC, getGRNUC, listGRNsUC)
        issueHandler := handler.NewGoodsIssueHandler(createIssueUC, getIssueUC, listIssuesUC)
        reservationHandler := handler.NewReservationHandler(createReservationUC, releaseReservationUC2, checkAvailabilityUC)
        adjustmentHandler := handler.NewAdjustmentHandler(createAdjustmentUC, transferStockUC)
        inventoryCountHandler := handler.NewInventoryCountHandler(
                createInventoryCountUC, startInventoryCountUC, recordCountUC,
                completeInventoryCountUC, getInventoryCountUC, listInventoryCountsUC,
        )
        healthHandler := handler.NewHealthHandler()

        // Setup router
        r := router.SetupRouter(
                warehouseHandler,
                stockHandler,
                lotHandler,
                grnHandler,
                issueHandler,
                reservationHandler,
                adjustmentHandler,
                inventoryCountHandler,
                healthHandler,
        )

        // Start scheduler for expiry alerts
        lowStockInterval, _ := time.ParseDuration(cfg.LowStockCheckInterval)
        if lowStockInterval == 0 </span><span class="cov0" title="0">{
                lowStockInterval = 1 * time.Hour
        }</span>
        <span class="cov0" title="0">schedulerConfig := &amp;scheduler.Config{
                ExpiryCheckInterval:   24 * time.Hour,
                LowStockCheckInterval: lowStockInterval,
                ExpiryAlertDays:       []int{90, 30, 7},
                LowStockThreshold:     100,
        }
        wmsScheduler := scheduler.NewScheduler(lotRepo, stockRepo, eventPub, log, schedulerConfig)
        wmsScheduler.Start()

        // Start gRPC server
        grpcPort := cfg.GRPCPort
        if grpcPort == "" </span><span class="cov0" title="0">{
                grpcPort = "9091"
        }</span>
        <span class="cov0" title="0">wmsGRPCServer := wmsgrpc.NewWMSServer(
                stockRepo, lotRepo,
                issueStockFEFOUC,
                createReservationUC, releaseReservationUC2, checkAvailabilityUC,
                log,
        )
        grpcServer := grpc.NewServer()
        _ = wmsGRPCServer // Register when proto is generated

        go func() </span><span class="cov0" title="0">{
                lis, err := net.Listen("tcp", ":"+grpcPort)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to listen for gRPC", zap.Error(err))
                        return
                }</span>
                <span class="cov0" title="0">log.Info("gRPC server started", zap.String("port", grpcPort))
                if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        log.Error("gRPC server error", zap.Error(err))
                }</span>
        }()

        // Start event subscriber
        <span class="cov0" title="0">var natsConn *natslib.Conn
        if natsClient != nil </span><span class="cov0" title="0">{
                natsConn = natsClient.Conn()
        }</span>
        <span class="cov0" title="0">eventSub := subscriber.NewEventSubscriber(
                natsConn,
                log,
                createGRNUC,
                createReservationUC,
                releaseReservationUC2,
        )
        if err := eventSub.Start(); err != nil </span><span class="cov0" title="0">{
                log.Warn("Failed to start event subscriber", zap.Error(err))
        }</span>

        // Start HTTP server
        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:    ":" + cfg.Port,
                Handler: r,
        }

        go func() </span><span class="cov0" title="0">{
                log.Info("HTTP server started", zap.String("port", cfg.Port))
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatal("Failed to start HTTP server", zap.Error(err))
                }</span>
        }()

        // Graceful shutdown
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit
        log.Info("Shutting down server...")

        // Stop scheduler
        wmsScheduler.Stop()

        // Stop event subscriber
        eventSub.Stop()

        // Stop gRPC server
        grpcServer.GracefulStop()

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server forced to shutdown", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if natsClient != nil </span><span class="cov0" title="0">{
                natsClient.Close()
        }</span>

        <span class="cov0" title="0">log.Info("Server exited properly")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/spf13/viper"
)

// Config holds the application configuration
type Config struct {
        ServiceName string `mapstructure:"SERVICE_NAME"`
        Environment string `mapstructure:"ENVIRONMENT"`
        Port        string `mapstructure:"PORT"`
        GRPCPort    string `mapstructure:"GRPC_PORT"`
        LogLevel    string `mapstructure:"LOG_LEVEL"`
        LogFormat   string `mapstructure:"LOG_FORMAT"`

        DBHost     string `mapstructure:"DB_HOST"`
        DBPort     string `mapstructure:"DB_PORT"`
        DBUser     string `mapstructure:"DB_USER"`
        DBPassword string `mapstructure:"DB_PASSWORD"`
        DBName     string `mapstructure:"DB_NAME"`
        DBSSLMode  string `mapstructure:"DB_SSL_MODE"`

        RedisHost     string `mapstructure:"REDIS_HOST"`
        RedisPort     string `mapstructure:"REDIS_PORT"`
        RedisPassword string `mapstructure:"REDIS_PASSWORD"`
        RedisDB       int    `mapstructure:"REDIS_DB"`

        NATSUrl string `mapstructure:"NATS_URL"`

        JWTSecret string `mapstructure:"JWT_SECRET"`

        // WMS Specific
        EnableFEFO             bool   `mapstructure:"ENABLE_FEFO"`
        ExpiryAlertDays        string `mapstructure:"EXPIRY_ALERT_DAYS"`
        LowStockCheckInterval  string `mapstructure:"LOW_STOCK_CHECK_INTERVAL"`
        ColdStorageMinTemp     int    `mapstructure:"COLD_STORAGE_MIN_TEMP"`
        ColdStorageMaxTemp     int    `mapstructure:"COLD_STORAGE_MAX_TEMP"`
}

// Load loads configuration
func Load() (*Config, error) <span class="cov0" title="0">{
        viper.AutomaticEnv()

        viper.SetDefault("SERVICE_NAME", "wms-service")
        viper.SetDefault("ENVIRONMENT", "development")
        viper.SetDefault("PORT", "8086")
        viper.SetDefault("GRPC_PORT", "9086")
        viper.SetDefault("LOG_LEVEL", "info")
        viper.SetDefault("LOG_FORMAT", "console")

        viper.SetDefault("DB_HOST", "localhost")
        viper.SetDefault("DB_PORT", "5432")
        viper.SetDefault("DB_USER", "postgres")
        viper.SetDefault("DB_PASSWORD", "postgres123")
        viper.SetDefault("DB_NAME", "wms_db")
        viper.SetDefault("DB_SSL_MODE", "disable")

        viper.SetDefault("REDIS_HOST", "localhost")
        viper.SetDefault("REDIS_PORT", "6379")
        viper.SetDefault("REDIS_DB", 0)

        viper.SetDefault("NATS_URL", "nats://localhost:4222")

        viper.SetDefault("ENABLE_FEFO", true)
        viper.SetDefault("EXPIRY_ALERT_DAYS", "90,30,7")
        viper.SetDefault("LOW_STOCK_CHECK_INTERVAL", "1h")
        viper.SetDefault("COLD_STORAGE_MIN_TEMP", 2)
        viper.SetDefault("COLD_STORAGE_MAX_TEMP", 8)

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var cfg Config
        if err := viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// GetDSN returns PostgreSQL connection string
func (c *Config) GetDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
                c.DBHost, c.DBPort, c.DBUser, c.DBPassword, c.DBName, c.DBSSLMode,
        )
}</span>

// GetRedisAddr returns Redis address
func (c *Config) GetRedisAddr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", c.RedisHost, c.RedisPort)
}</span>

// GetNATSReconnectWait returns NATS reconnect wait
func (c *Config) GetNATSReconnectWait() time.Duration <span class="cov0" title="0">{
        return 2 * time.Second
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package grpc

import (
        "context"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/erp-cosmetics/wms-service/internal/usecase/reservation"
        "github.com/erp-cosmetics/wms-service/internal/usecase/stock"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// WMSServer implements the WMS gRPC service
type WMSServer struct {
        UnimplementedWMSServiceServer
        stockRepo            repository.StockRepository
        lotRepo              repository.LotRepository
        issueStockFEFOUC     *stock.IssueStockFEFOUseCase
        reserveStockUC       *reservation.CreateReservationUseCase
        releaseReservationUC *reservation.ReleaseReservationUseCase
        checkAvailabilityUC  *reservation.CheckAvailabilityUseCase
        logger               *zap.Logger
}

// NewWMSServer creates a new WMS gRPC server
func NewWMSServer(
        stockRepo repository.StockRepository,
        lotRepo repository.LotRepository,
        issueStockFEFOUC *stock.IssueStockFEFOUseCase,
        reserveStockUC *reservation.CreateReservationUseCase,
        releaseReservationUC *reservation.ReleaseReservationUseCase,
        checkAvailabilityUC *reservation.CheckAvailabilityUseCase,
        logger *zap.Logger,
) *WMSServer <span class="cov0" title="0">{
        return &amp;WMSServer{
                stockRepo:            stockRepo,
                lotRepo:              lotRepo,
                issueStockFEFOUC:     issueStockFEFOUC,
                reserveStockUC:       reserveStockUC,
                releaseReservationUC: releaseReservationUC,
                checkAvailabilityUC:  checkAvailabilityUC,
                logger:               logger,
        }
}</span>

// CheckStockAvailability checks if material has sufficient stock
func (s *WMSServer) CheckStockAvailability(ctx context.Context, req *CheckStockRequest) (*StockAvailabilityResponse, error) <span class="cov0" title="0">{
        materialID, err := uuid.Parse(req.MaterialId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid material_id")
        }</span>

        <span class="cov0" title="0">result, err := s.checkAvailabilityUC.Execute(ctx, materialID, req.RequestedQuantity)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;StockAvailabilityResponse{
                MaterialId:        req.MaterialId,
                TotalQuantity:     result.TotalQuantity,
                ReservedQuantity:  result.ReservedQty,
                AvailableQuantity: result.AvailableQty,
                IsAvailable:       result.IsAvailable,
                ShortageQuantity:  result.ShortageQty,
        }, nil</span>
}

// ReserveStock reserves stock for an order
func (s *WMSServer) ReserveStock(ctx context.Context, req *ReserveStockRequest) (*ReserveStockResponse, error) <span class="cov0" title="0">{
        materialID, err := uuid.Parse(req.MaterialId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid material_id")
        }</span>

        <span class="cov0" title="0">unitID, err := uuid.Parse(req.UnitId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid unit_id")
        }</span>

        <span class="cov0" title="0">referenceID, err := uuid.Parse(req.ReferenceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid reference_id")
        }</span>

        <span class="cov0" title="0">input := &amp;reservation.CreateReservationInput{
                MaterialID:      materialID,
                Quantity:        req.Quantity,
                UnitID:          unitID,
                ReservationType: entity.ReservationType(req.ReservationType),
                ReferenceID:     referenceID,
                ReferenceNumber: req.ReferenceNumber,
                CreatedBy:       uuid.New(), // Should come from context
        }

        result, err := s.reserveStockUC.Execute(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                if err == entity.ErrInsufficientStock </span><span class="cov0" title="0">{
                        return &amp;ReserveStockResponse{
                                Success: false,
                                Message: "Insufficient stock for reservation",
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, status.Error(codes.Internal, err.Error())</span>
        }

        <span class="cov0" title="0">return &amp;ReserveStockResponse{
                ReservationId:    result.ID.String(),
                ReservedQuantity: result.Quantity,
                Success:          true,
                Message:          "Stock reserved successfully",
        }, nil</span>
}

// ReleaseReservation releases a stock reservation
func (s *WMSServer) ReleaseReservation(ctx context.Context, req *ReleaseReservationRequest) (*ReleaseReservationResponse, error) <span class="cov0" title="0">{
        reservationID, err := uuid.Parse(req.ReservationId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid reservation_id")
        }</span>

        <span class="cov0" title="0">if err := s.releaseReservationUC.Execute(ctx, reservationID); err != nil </span><span class="cov0" title="0">{
                return &amp;ReleaseReservationResponse{Success: false}, nil
        }</span>

        <span class="cov0" title="0">return &amp;ReleaseReservationResponse{Success: true}, nil</span>
}

// IssueStock issues stock using FEFO logic
func (s *WMSServer) IssueStock(ctx context.Context, req *IssueStockRequest) (*IssueStockResponse, error) <span class="cov0" title="0">{
        issuedBy, _ := uuid.Parse(req.IssuedBy)
        referenceID, _ := uuid.Parse(req.ReferenceId)

        var lineItems []*IssueLineItem

        for _, item := range req.Items </span><span class="cov0" title="0">{
                materialID, err := uuid.Parse(item.MaterialId)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">unitID, err := uuid.Parse(item.UnitId)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">input := &amp;stock.IssueStockInput{
                        MaterialID:      materialID,
                        Quantity:        item.Quantity,
                        UnitID:          unitID,
                        ReferenceType:   entity.ReferenceType(req.ReferenceType),
                        ReferenceID:     &amp;referenceID,
                        ReferenceNumber: req.ReferenceNumber,
                        CreatedBy:       issuedBy,
                }

                result, err := s.issueStockFEFOUC.Execute(ctx, input)
                if err != nil </span><span class="cov0" title="0">{
                        if err == entity.ErrInsufficientStock </span><span class="cov0" title="0">{
                                return &amp;IssueStockResponse{
                                        Success: false,
                                        Message: "Insufficient stock for material: " + item.MaterialId,
                                }, nil
                        }</span>
                        <span class="cov0" title="0">return nil, status.Error(codes.Internal, err.Error())</span>
                }

                // Convert lots issued to proto format
                <span class="cov0" title="0">lotsUsed := make([]*LotIssued, len(result.LotsIssued))
                for i, lot := range result.LotsIssued </span><span class="cov0" title="0">{
                        lotsUsed[i] = &amp;LotIssued{
                                LotId:      lot.LotID.String(),
                                LotNumber:  lot.LotNumber,
                                Quantity:   lot.Quantity,
                                ExpiryDate: timestamppb.New(lot.ExpiryDate),
                                LocationId: lot.LocationID.String(),
                        }
                }</span>

                <span class="cov0" title="0">lineItems = append(lineItems, &amp;IssueLineItem{
                        MaterialId:     item.MaterialId,
                        IssuedQuantity: item.Quantity,
                        LotsUsed:       lotsUsed,
                })</span>
        }

        <span class="cov0" title="0">return &amp;IssueStockResponse{
                IssueNumber: time.Now().Format("GI-20060102-1504"),
                LineItems:   lineItems,
                Success:     true,
                Message:     "Stock issued successfully",
        }, nil</span>
}

// GetLotInfo gets lot information
func (s *WMSServer) GetLotInfo(ctx context.Context, req *GetLotRequest) (*LotInfoResponse, error) <span class="cov0" title="0">{
        lotID, err := uuid.Parse(req.LotId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid lot_id")
        }</span>

        <span class="cov0" title="0">lot, err := s.lotRepo.GetByID(ctx, lotID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "lot not found")
        }</span>

        // Get available quantity from stock
        <span class="cov0" title="0">stocks, _ := s.stockRepo.GetByMaterialAndLot(ctx, lot.MaterialID, lot.ID)
        availableQty := 0.0
        if stocks != nil </span><span class="cov0" title="0">{
                availableQty = stocks.Quantity - stocks.ReservedQty
        }</span>

        <span class="cov0" title="0">return &amp;LotInfoResponse{
                Lot: &amp;LotInfo{
                        LotId:             lot.ID.String(),
                        LotNumber:         lot.LotNumber,
                        MaterialId:        lot.MaterialID.String(),
                        ExpiryDate:        timestamppb.New(lot.ExpiryDate),
                        QcStatus:          string(lot.QCStatus),
                        Status:            string(lot.Status),
                        AvailableQuantity: availableQty,
                },
        }, nil</span>
}

// GetLotsByMaterial gets lots for a material
func (s *WMSServer) GetLotsByMaterial(ctx context.Context, req *GetLotsByMaterialRequest) (*LotsResponse, error) <span class="cov0" title="0">{
        materialID, err := uuid.Parse(req.MaterialId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "invalid material_id")
        }</span>

        <span class="cov0" title="0">var lots []*entity.Lot
        if req.AvailableOnly </span><span class="cov0" title="0">{
                lots, err = s.lotRepo.GetAvailableLots(ctx, materialID)
        }</span> else<span class="cov0" title="0"> {
                filter := &amp;repository.LotFilter{MaterialID: &amp;materialID, Limit: 100}
                lots, _, err = s.lotRepo.List(ctx, filter)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov0" title="0">lotInfos := make([]*LotInfo, len(lots))
        for i, lot := range lots </span><span class="cov0" title="0">{
                lotInfos[i] = &amp;LotInfo{
                        LotId:      lot.ID.String(),
                        LotNumber:  lot.LotNumber,
                        MaterialId: lot.MaterialID.String(),
                        ExpiryDate: timestamppb.New(lot.ExpiryDate),
                        QcStatus:   string(lot.QCStatus),
                        Status:     string(lot.Status),
                }
        }</span>

        <span class="cov0" title="0">return &amp;LotsResponse{Lots: lotInfos}, nil</span>
}

// ReceiveStock handles receiving stock from procurement
func (s *WMSServer) ReceiveStock(ctx context.Context, req *ReceiveStockRequest) (*ReceiveStockResponse, error) <span class="cov0" title="0">{
        // This would create GRN and receive stock
        // For now, just return success
        return &amp;ReceiveStockResponse{
                GrnNumber: "GRN-" + time.Now().Format("20060102-1504"),
                Success:   true,
        }, nil
}</span>

// UnimplementedWMSServiceServer is embedded to ensure forward compatibility
type UnimplementedWMSServiceServer struct{}

func (UnimplementedWMSServiceServer) CheckStockAvailability(context.Context, *CheckStockRequest) (*StockAvailabilityResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CheckStockAvailability not implemented")
}</span>
func (UnimplementedWMSServiceServer) ReserveStock(context.Context, *ReserveStockRequest) (*ReserveStockResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ReserveStock not implemented")
}</span>
func (UnimplementedWMSServiceServer) ReleaseReservation(context.Context, *ReleaseReservationRequest) (*ReleaseReservationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ReleaseReservation not implemented")
}</span>
func (UnimplementedWMSServiceServer) IssueStock(context.Context, *IssueStockRequest) (*IssueStockResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method IssueStock not implemented")
}</span>
func (UnimplementedWMSServiceServer) GetLotInfo(context.Context, *GetLotRequest) (*LotInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetLotInfo not implemented")
}</span>
func (UnimplementedWMSServiceServer) GetLotsByMaterial(context.Context, *GetLotsByMaterialRequest) (*LotsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetLotsByMaterial not implemented")
}</span>
func (UnimplementedWMSServiceServer) ReceiveStock(context.Context, *ReceiveStockRequest) (*ReceiveStockResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ReceiveStock not implemented")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "time"

        "github.com/erp-cosmetics/wms-service/internal/delivery/http/dto"
        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/erp-cosmetics/wms-service/internal/usecase/grn"
        "github.com/erp-cosmetics/shared/pkg/errors"
        "github.com/erp-cosmetics/shared/pkg/response"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// GRNHandler handles GRN endpoints
type GRNHandler struct {
        createGRNUC   *grn.CreateGRNUseCase
        completeGRNUC *grn.CompleteGRNUseCase
        getGRNUC      *grn.GetGRNUseCase
        listGRNsUC    *grn.ListGRNsUseCase
}

// NewGRNHandler creates a new GRN handler
func NewGRNHandler(
        createGRNUC *grn.CreateGRNUseCase,
        completeGRNUC *grn.CompleteGRNUseCase,
        getGRNUC *grn.GetGRNUseCase,
        listGRNsUC *grn.ListGRNsUseCase,
) *GRNHandler <span class="cov0" title="0">{
        return &amp;GRNHandler{
                createGRNUC:   createGRNUC,
                completeGRNUC: completeGRNUC,
                getGRNUC:      getGRNUC,
                listGRNsUC:    listGRNsUC,
        }
}</span>

// CreateGRN handles POST /grn
func (h *GRNHandler) CreateGRN(c *gin.Context) <span class="cov0" title="0">{
        var req dto.CreateGRNRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">grnDate, err := time.Parse("2006-01-02", req.GRNDate)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid GRN date format"))
                return
        }</span>

        // Get user ID from context (for now use a placeholder)
        <span class="cov0" title="0">userID := uuid.New()

        input := &amp;grn.CreateGRNInput{
                GRNDate:            grnDate,
                POID:               req.POID,
                PONumber:           req.PONumber,
                SupplierID:         req.SupplierID,
                WarehouseID:        req.WarehouseID,
                DeliveryNoteNumber: req.DeliveryNoteNumber,
                VehicleNumber:      req.VehicleNumber,
                Notes:              req.Notes,
                ReceivedBy:         userID,
                Items:              make([]grn.CreateGRNItemInput, len(req.Items)),
        }

        for i, item := range req.Items </span><span class="cov0" title="0">{
                expiryDate, err := time.Parse("2006-01-02", item.ExpiryDate)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(c, errors.BadRequest("Invalid expiry date format"))
                        return
                }</span>

                <span class="cov0" title="0">var manufacturedDate *time.Time
                if item.ManufacturedDate != nil </span><span class="cov0" title="0">{
                        d, _ := time.Parse("2006-01-02", *item.ManufacturedDate)
                        manufacturedDate = &amp;d
                }</span>

                <span class="cov0" title="0">input.Items[i] = grn.CreateGRNItemInput{
                        POLineItemID:      item.POLineItemID,
                        MaterialID:        item.MaterialID,
                        ExpectedQty:       item.ExpectedQty,
                        ReceivedQty:       item.ReceivedQty,
                        UnitID:            item.UnitID,
                        SupplierLotNumber: item.SupplierLotNumber,
                        ManufacturedDate:  manufacturedDate,
                        ExpiryDate:        expiryDate,
                        LocationID:        item.LocationID,
                }</span>
        }

        <span class="cov0" title="0">result, err := h.createGRNUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.Created(c, gin.H{
                "id":         result.ID,
                "grn_number": result.GRNNumber,
                "status":     result.Status,
        })</span>
}

// GetGRN handles GET /grn/:id
func (h *GRNHandler) GetGRN(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid GRN ID"))
                return
        }</span>

        <span class="cov0" title="0">result, err := h.getGRNUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.NotFound("GRN"))
                return
        }</span>

        <span class="cov0" title="0">resp := toGRNResponse(result)
        response.Success(c, resp)</span>
}

// ListGRNs handles GET /grn
func (h *GRNHandler) ListGRNs(c *gin.Context) <span class="cov0" title="0">{
        filter := &amp;repository.GRNFilter{
                Status:   c.Query("status"),
                QCStatus: c.Query("qc_status"),
                Search:   c.Query("search"),
                Page:     getPageParam(c),
                Limit:    getLimitParam(c),
        }

        if warehouseID := c.Query("warehouse_id"); warehouseID != "" </span><span class="cov0" title="0">{
                id, _ := uuid.Parse(warehouseID)
                filter.WarehouseID = &amp;id
        }</span>
        <span class="cov0" title="0">if poID := c.Query("po_id"); poID != "" </span><span class="cov0" title="0">{
                id, _ := uuid.Parse(poID)
                filter.POID = &amp;id
        }</span>

        <span class="cov0" title="0">grns, total, err := h.listGRNsUC.Execute(c.Request.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">var items []dto.GRNResponse
        for _, g := range grns </span><span class="cov0" title="0">{
                items = append(items, toGRNResponse(g))
        }</span>

        <span class="cov0" title="0">response.SuccessWithMeta(c, items, response.NewMeta(filter.Page, filter.Limit, int64(total)))</span>
}

// CompleteGRN handles PATCH /grn/:id/complete
func (h *GRNHandler) CompleteGRN(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid GRN ID"))
                return
        }</span>

        <span class="cov0" title="0">var req dto.CompleteGRNRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">input := &amp;grn.CompleteGRNInput{
                GRNID:    id,
                QCStatus: entity.QCStatus(req.QCStatus),
                QCNotes:  req.QCNotes,
        }

        result, err := h.completeGRNUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                if err == entity.ErrAlreadyCompleted </span><span class="cov0" title="0">{
                        response.Error(c, errors.BadRequest("GRN already completed"))
                        return
                }</span>
                <span class="cov0" title="0">response.Error(c, errors.Internal(err))
                return</span>
        }

        <span class="cov0" title="0">response.Success(c, toGRNResponse(result))</span>
}

func toGRNResponse(g *entity.GRN) dto.GRNResponse <span class="cov0" title="0">{
        resp := dto.GRNResponse{
                ID:                 g.ID,
                GRNNumber:          g.GRNNumber,
                GRNDate:            g.GRNDate.Format("2006-01-02"),
                PONumber:           g.PONumber,
                WarehouseID:        g.WarehouseID,
                DeliveryNoteNumber: g.DeliveryNoteNumber,
                VehicleNumber:      g.VehicleNumber,
                Status:             string(g.Status),
                QCStatus:           string(g.QCStatus),
                QCNotes:            g.QCNotes,
                Notes:              g.Notes,
                CompletedAt:        g.CompletedAt,
                CreatedAt:          g.CreatedAt,
        }

        if g.Warehouse != nil </span><span class="cov0" title="0">{
                resp.WarehouseName = g.Warehouse.Name
        }</span>

        <span class="cov0" title="0">for _, item := range g.LineItems </span><span class="cov0" title="0">{
                lineItem := dto.GRNLineItemResponse{
                        ID:                item.ID,
                        LineNumber:        item.LineNumber,
                        MaterialID:        item.MaterialID,
                        ExpectedQty:       item.ExpectedQty,
                        ReceivedQty:       item.ReceivedQty,
                        AcceptedQty:       item.AcceptedQty,
                        RejectedQty:       item.RejectedQty,
                        SupplierLotNumber: item.SupplierLotNumber,
                        ExpiryDate:        item.ExpiryDate.Format("2006-01-02"),
                        QCStatus:          string(item.QCStatus),
                }

                if item.Lot != nil </span><span class="cov0" title="0">{
                        lineItem.LotNumber = item.Lot.LotNumber
                }</span>
                <span class="cov0" title="0">if item.Location != nil </span><span class="cov0" title="0">{
                        lineItem.LocationCode = item.Location.Code
                }</span>

                <span class="cov0" title="0">resp.LineItems = append(resp.LineItems, lineItem)</span>
        }

        <span class="cov0" title="0">return resp</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

// HealthHandler handles health check endpoints
type HealthHandler struct{}

// NewHealthHandler creates a new health handler
func NewHealthHandler() *HealthHandler <span class="cov0" title="0">{
        return &amp;HealthHandler{}
}</span>

// Health handles GET /health
func (h *HealthHandler) Health(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status":  "healthy",
                "service": "wms-service",
        })
}</span>

// Ready handles GET /ready
func (h *HealthHandler) Ready(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status": "ready",
        })
}</span>

// Live handles GET /live
func (h *HealthHandler) Live(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status": "alive",
        })
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/erp-cosmetics/wms-service/internal/usecase/inventory"
        "github.com/erp-cosmetics/shared/pkg/errors"
        "github.com/erp-cosmetics/shared/pkg/response"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// InventoryCountHandler handles inventory count endpoints
type InventoryCountHandler struct {
        createCountUC   *inventory.CreateInventoryCountUseCase
        startCountUC    *inventory.StartInventoryCountUseCase
        recordCountUC   *inventory.RecordCountUseCase
        completeCountUC *inventory.CompleteInventoryCountUseCase
        getCountUC      *inventory.GetInventoryCountUseCase
        listCountsUC    *inventory.ListInventoryCountsUseCase
}

// NewInventoryCountHandler creates a new handler
func NewInventoryCountHandler(
        createCountUC *inventory.CreateInventoryCountUseCase,
        startCountUC *inventory.StartInventoryCountUseCase,
        recordCountUC *inventory.RecordCountUseCase,
        completeCountUC *inventory.CompleteInventoryCountUseCase,
        getCountUC *inventory.GetInventoryCountUseCase,
        listCountsUC *inventory.ListInventoryCountsUseCase,
) *InventoryCountHandler <span class="cov0" title="0">{
        return &amp;InventoryCountHandler{
                createCountUC:   createCountUC,
                startCountUC:    startCountUC,
                recordCountUC:   recordCountUC,
                completeCountUC: completeCountUC,
                getCountUC:      getCountUC,
                listCountsUC:    listCountsUC,
        }
}</span>

// CreateInventoryCountRequest represents create request
type CreateInventoryCountRequest struct {
        CountDate   string     `json:"count_date" binding:"required"`
        CountType   string     `json:"count_type" binding:"required,oneof=FULL CYCLE SPOT"`
        WarehouseID uuid.UUID  `json:"warehouse_id" binding:"required"`
        ZoneID      *uuid.UUID `json:"zone_id"`
        Notes       string     `json:"notes"`
}

// CreateInventoryCount handles POST /inventory-counts
func (h *InventoryCountHandler) CreateInventoryCount(c *gin.Context) <span class="cov0" title="0">{
        var req CreateInventoryCountRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">countDate, err := time.Parse("2006-01-02", req.CountDate)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid count date format"))
                return
        }</span>

        <span class="cov0" title="0">userID := uuid.New() // Placeholder

        input := &amp;inventory.CreateInventoryCountInput{
                CountDate:   countDate,
                CountType:   entity.InventoryCountType(req.CountType),
                WarehouseID: req.WarehouseID,
                ZoneID:      req.ZoneID,
                Notes:       req.Notes,
                CreatedBy:   userID,
        }

        result, err := h.createCountUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.Created(c, gin.H{
                "id":           result.ID,
                "count_number": result.CountNumber,
                "status":       result.Status,
        })</span>
}

// GetInventoryCount handles GET /inventory-counts/:id
func (h *InventoryCountHandler) GetInventoryCount(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid count ID"))
                return
        }</span>

        <span class="cov0" title="0">result, err := h.getCountUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.NotFound("Inventory Count"))
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, result)</span>
}

// ListInventoryCounts handles GET /inventory-counts
func (h *InventoryCountHandler) ListInventoryCounts(c *gin.Context) <span class="cov0" title="0">{
        filter := &amp;repository.InventoryCountFilter{
                Status:    c.Query("status"),
                CountType: c.Query("count_type"),
                Search:    c.Query("search"),
                Page:      getPageParam(c),
                Limit:     getLimitParam(c),
        }

        if warehouseID := c.Query("warehouse_id"); warehouseID != "" </span><span class="cov0" title="0">{
                id, _ := uuid.Parse(warehouseID)
                filter.WarehouseID = &amp;id
        }</span>

        <span class="cov0" title="0">counts, total, err := h.listCountsUC.Execute(c.Request.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.SuccessWithMeta(c, counts, response.NewMeta(filter.Page, filter.Limit, int64(total)))</span>
}

// StartInventoryCount handles PATCH /inventory-counts/:id/start
func (h *InventoryCountHandler) StartInventoryCount(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid count ID"))
                return
        }</span>

        <span class="cov0" title="0">result, err := h.startCountUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if err == entity.ErrInvalidStatus </span><span class="cov0" title="0">{
                        response.Error(c, errors.BadRequest("Cannot start count in current status"))
                        return
                }</span>
                <span class="cov0" title="0">response.Error(c, errors.Internal(err))
                return</span>
        }

        <span class="cov0" title="0">response.Success(c, gin.H{
                "id":     result.ID,
                "status": result.Status,
        })</span>
}

// RecordCountRequest represents record count request
type RecordCountRequest struct {
        LineItemID uuid.UUID `json:"line_item_id" binding:"required"`
        CountedQty float64   `json:"counted_qty" binding:"required"`
        Notes      string    `json:"notes"`
}

// RecordCount handles POST /inventory-counts/:id/record
func (h *InventoryCountHandler) RecordCount(c *gin.Context) <span class="cov0" title="0">{
        var req RecordCountRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">userID := uuid.New() // Placeholder

        input := &amp;inventory.RecordCountInput{
                LineItemID: req.LineItemID,
                CountedQty: req.CountedQty,
                CountedBy:  userID,
                Notes:      req.Notes,
        }

        result, err := h.recordCountUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, gin.H{
                "id":        result.ID,
                "variance":  result.Variance,
                "is_counted": result.IsCounted,
        })</span>
}

// CompleteInventoryCountRequest represents complete request
type CompleteInventoryCountRequest struct {
        ApplyVariance bool `json:"apply_variance"`
}

// CompleteInventoryCount handles PATCH /inventory-counts/:id/complete
func (h *InventoryCountHandler) CompleteInventoryCount(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid count ID"))
                return
        }</span>

        <span class="cov0" title="0">var req CompleteInventoryCountRequest
        c.ShouldBindJSON(&amp;req)

        userID := uuid.New() // Placeholder

        input := &amp;inventory.CompleteInventoryCountInput{
                CountID:       id,
                ApplyVariance: req.ApplyVariance,
                ApprovedBy:    userID,
        }

        result, err := h.completeCountUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                if err == entity.ErrInvalidStatus </span><span class="cov0" title="0">{
                        response.Error(c, errors.BadRequest("Cannot complete count in current status"))
                        return
                }</span>
                <span class="cov0" title="0">if err == entity.ErrPendingItems </span><span class="cov0" title="0">{
                        response.Error(c, errors.BadRequest("All items must be counted before completion"))
                        return
                }</span>
                <span class="cov0" title="0">response.Error(c, errors.Internal(err))
                return</span>
        }

        <span class="cov0" title="0">response.Success(c, gin.H{
                "id":     result.ID,
                "status": result.Status,
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "time"

        "github.com/erp-cosmetics/wms-service/internal/delivery/http/dto"
        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/erp-cosmetics/wms-service/internal/usecase/issue"
        "github.com/erp-cosmetics/shared/pkg/errors"
        "github.com/erp-cosmetics/shared/pkg/response"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// GoodsIssueHandler handles goods issue endpoints
type GoodsIssueHandler struct {
        createIssueUC *issue.CreateGoodsIssueUseCase
        getIssueUC    *issue.GetGoodsIssueUseCase
        listIssuesUC  *issue.ListGoodsIssuesUseCase
}

// NewGoodsIssueHandler creates a new goods issue handler
func NewGoodsIssueHandler(
        createIssueUC *issue.CreateGoodsIssueUseCase,
        getIssueUC *issue.GetGoodsIssueUseCase,
        listIssuesUC *issue.ListGoodsIssuesUseCase,
) *GoodsIssueHandler <span class="cov0" title="0">{
        return &amp;GoodsIssueHandler{
                createIssueUC: createIssueUC,
                getIssueUC:    getIssueUC,
                listIssuesUC:  listIssuesUC,
        }
}</span>

// CreateGoodsIssue handles POST /goods-issue
func (h *GoodsIssueHandler) CreateGoodsIssue(c *gin.Context) <span class="cov0" title="0">{
        var req dto.IssueStockRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">issueDate, err := time.Parse("2006-01-02", req.IssueDate)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid issue date format"))
                return
        }</span>

        // Get user ID (placeholder)
        <span class="cov0" title="0">userID := uuid.New()

        input := &amp;issue.CreateGoodsIssueInput{
                IssueDate:       issueDate,
                IssueType:       entity.IssueType(req.IssueType),
                ReferenceID:     req.ReferenceID,
                ReferenceNumber: req.ReferenceNumber,
                WarehouseID:     req.WarehouseID,
                Notes:           req.Notes,
                IssuedBy:        userID,
                Items:           make([]issue.CreateGoodsIssueItemInput, len(req.Items)),
        }

        for i, item := range req.Items </span><span class="cov0" title="0">{
                input.Items[i] = issue.CreateGoodsIssueItemInput{
                        MaterialID: item.MaterialID,
                        Quantity:   item.Quantity,
                        UnitID:     item.UnitID,
                }
        }</span>

        <span class="cov0" title="0">result, err := h.createIssueUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                if err == entity.ErrInsufficientStock </span><span class="cov0" title="0">{
                        response.Error(c, errors.BadRequest("Insufficient stock available"))
                        return
                }</span>
                <span class="cov0" title="0">response.Error(c, errors.Internal(err))
                return</span>
        }

        // Convert lots issued to response format
        <span class="cov0" title="0">lineItems := make([]dto.IssueStockResponse, len(result.LineItems))
        for i, li := range result.LineItems </span><span class="cov0" title="0">{
                lotsUsed := make([]dto.LotIssuedResponse, len(li.LotsUsed))
                for j, lot := range li.LotsUsed </span><span class="cov0" title="0">{
                        lotsUsed[j] = dto.LotIssuedResponse{
                                LotNumber:  lot.LotNumber,
                                Quantity:   lot.Quantity,
                                ExpiryDate: lot.ExpiryDate.Format("2006-01-02"),
                        }
                }</span>
                <span class="cov0" title="0">lineItems[i] = dto.IssueStockResponse{
                        IssueNumber: result.IssueNumber,
                        LotsIssued:  lotsUsed,
                }</span>
        }

        <span class="cov0" title="0">response.Created(c, gin.H{
                "id":           result.ID,
                "issue_number": result.IssueNumber,
                "status":       result.Status,
                "line_items":   lineItems,
        })</span>
}

// GetGoodsIssue handles GET /goods-issue/:id
func (h *GoodsIssueHandler) GetGoodsIssue(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid goods issue ID"))
                return
        }</span>

        <span class="cov0" title="0">result, err := h.getIssueUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.NotFound("Goods Issue"))
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, result)</span>
}

// ListGoodsIssues handles GET /goods-issue
func (h *GoodsIssueHandler) ListGoodsIssues(c *gin.Context) <span class="cov0" title="0">{
        filter := &amp;repository.GoodsIssueFilter{
                IssueType: c.Query("issue_type"),
                Status:    c.Query("status"),
                Search:    c.Query("search"),
                Page:      getPageParam(c),
                Limit:     getLimitParam(c),
        }

        if warehouseID := c.Query("warehouse_id"); warehouseID != "" </span><span class="cov0" title="0">{
                id, _ := uuid.Parse(warehouseID)
                filter.WarehouseID = &amp;id
        }</span>

        <span class="cov0" title="0">issues, total, err := h.listIssuesUC.Execute(c.Request.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.SuccessWithMeta(c, issues, response.NewMeta(filter.Page, filter.Limit, int64(total)))</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "time"

        "github.com/erp-cosmetics/wms-service/internal/delivery/http/dto"
        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/usecase/adjustment"
        "github.com/erp-cosmetics/wms-service/internal/usecase/reservation"
        "github.com/erp-cosmetics/shared/pkg/errors"
        "github.com/erp-cosmetics/shared/pkg/response"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// ReservationHandler handles reservation endpoints
type ReservationHandler struct {
        createReservationUC   *reservation.CreateReservationUseCase
        releaseReservationUC  *reservation.ReleaseReservationUseCase
        checkAvailabilityUC   *reservation.CheckAvailabilityUseCase
}

// NewReservationHandler creates a new reservation handler
func NewReservationHandler(
        createReservationUC *reservation.CreateReservationUseCase,
        releaseReservationUC *reservation.ReleaseReservationUseCase,
        checkAvailabilityUC *reservation.CheckAvailabilityUseCase,
) *ReservationHandler <span class="cov0" title="0">{
        return &amp;ReservationHandler{
                createReservationUC:  createReservationUC,
                releaseReservationUC: releaseReservationUC,
                checkAvailabilityUC:  checkAvailabilityUC,
        }
}</span>

// CreateReservation handles POST /reservations
func (h *ReservationHandler) CreateReservation(c *gin.Context) <span class="cov0" title="0">{
        var req dto.ReserveStockRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">var expiresAt *time.Time
        if req.ExpiresAt != nil </span><span class="cov0" title="0">{
                t, _ := time.Parse(time.RFC3339, *req.ExpiresAt)
                expiresAt = &amp;t
        }</span>

        <span class="cov0" title="0">userID := uuid.New() // Placeholder

        input := &amp;reservation.CreateReservationInput{
                MaterialID:      req.MaterialID,
                Quantity:        req.Quantity,
                UnitID:          req.UnitID,
                ReservationType: entity.ReservationType(req.ReservationType),
                ReferenceID:     req.ReferenceID,
                ReferenceNumber: req.ReferenceNumber,
                ExpiresAt:       expiresAt,
                CreatedBy:       userID,
        }

        result, err := h.createReservationUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                if err == entity.ErrInsufficientStock </span><span class="cov0" title="0">{
                        response.Error(c, errors.BadRequest("Insufficient stock for reservation"))
                        return
                }</span>
                <span class="cov0" title="0">response.Error(c, errors.Internal(err))
                return</span>
        }

        <span class="cov0" title="0">response.Created(c, dto.ReserveStockResponse{
                ReservationID:    result.ID,
                ReservedQuantity: result.Quantity,
        })</span>
}

// ReleaseReservation handles DELETE /reservations/:id
func (h *ReservationHandler) ReleaseReservation(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid reservation ID"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.releaseReservationUC.Execute(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.NoContent(c)</span>
}

// CheckAvailability handles GET /stock/availability/:material_id
func (h *ReservationHandler) CheckAvailability(c *gin.Context) <span class="cov0" title="0">{
        materialID, err := uuid.Parse(c.Param("material_id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid material ID"))
                return
        }</span>

        <span class="cov0" title="0">requestedQty := 0.0
        if qty := c.Query("quantity"); qty != "" </span><span class="cov0" title="0">{
                var q float64
                if _, err := c.GetQuery("quantity"); err </span>{<span class="cov0" title="0">
                        // parse the quantity
                }</span>
                <span class="cov0" title="0">requestedQty = q</span>
        }

        <span class="cov0" title="0">result, err := h.checkAvailabilityUC.Execute(c.Request.Context(), materialID, requestedQty)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, result)</span>
}

// AdjustmentHandler handles stock adjustment endpoints
type AdjustmentHandler struct {
        createAdjustmentUC *adjustment.CreateAdjustmentUseCase
        transferStockUC    *adjustment.TransferStockUseCase
}

// NewAdjustmentHandler creates a new adjustment handler
func NewAdjustmentHandler(
        createAdjustmentUC *adjustment.CreateAdjustmentUseCase,
        transferStockUC *adjustment.TransferStockUseCase,
) *AdjustmentHandler <span class="cov0" title="0">{
        return &amp;AdjustmentHandler{
                createAdjustmentUC: createAdjustmentUC,
                transferStockUC:    transferStockUC,
        }
}</span>

// CreateAdjustment handles POST /adjustments
func (h *AdjustmentHandler) CreateAdjustment(c *gin.Context) <span class="cov0" title="0">{
        var req dto.AdjustmentRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">adjustmentDate, err := time.Parse("2006-01-02", req.AdjustmentDate)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid adjustment date format"))
                return
        }</span>

        <span class="cov0" title="0">userID := uuid.New() // Placeholder

        input := &amp;adjustment.CreateAdjustmentInput{
                AdjustmentDate: adjustmentDate,
                AdjustmentType: adjustment.AdjustmentType(req.AdjustmentType),
                LocationID:     req.LocationID,
                MaterialID:     req.MaterialID,
                LotID:          req.LotID,
                UnitID:         req.UnitID,
                SystemQty:      req.SystemQty,
                ActualQty:      req.ActualQty,
                Reason:         req.Reason,
                Notes:          req.Notes,
                AdjustedBy:     userID,
        }

        result, err := h.createAdjustmentUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.Created(c, gin.H{
                "adjustment_number": result.AdjustmentNumber,
                "variance":          result.Variance,
                "movement_number":   result.MovementNumber,
        })</span>
}

// TransferStock handles POST /transfers
func (h *AdjustmentHandler) TransferStock(c *gin.Context) <span class="cov0" title="0">{
        var req dto.TransferStockRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">userID := uuid.New() // Placeholder

        input := &amp;adjustment.TransferStockInput{
                MaterialID:     req.MaterialID,
                LotID:          req.LotID,
                FromLocationID: req.FromLocationID,
                ToLocationID:   req.ToLocationID,
                Quantity:       req.Quantity,
                UnitID:         req.UnitID,
                Reason:         req.Reason,
                TransferredBy:  userID,
        }

        movementNumber, err := h.transferStockUC.Execute(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                if err == entity.ErrInsufficientStock </span><span class="cov0" title="0">{
                        response.Error(c, errors.BadRequest("Insufficient stock for transfer"))
                        return
                }</span>
                <span class="cov0" title="0">response.Error(c, errors.Internal(err))
                return</span>
        }

        <span class="cov0" title="0">response.Created(c, gin.H{
                "movement_number": movementNumber,
        })</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "strconv"

        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/erp-cosmetics/wms-service/internal/usecase/lot"
        "github.com/erp-cosmetics/wms-service/internal/usecase/stock"
        "github.com/erp-cosmetics/wms-service/internal/usecase/warehouse"
        "github.com/erp-cosmetics/shared/pkg/errors"
        "github.com/erp-cosmetics/shared/pkg/response"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// WarehouseHandler handles warehouse endpoints
type WarehouseHandler struct {
        listWarehousesUC *warehouse.ListWarehousesUseCase
        getWarehouseUC   *warehouse.GetWarehouseUseCase
        getZonesUC       *warehouse.GetZonesUseCase
        getLocationsUC   *warehouse.GetLocationsUseCase
}

// NewWarehouseHandler creates a new warehouse handler
func NewWarehouseHandler(
        listWarehousesUC *warehouse.ListWarehousesUseCase,
        getWarehouseUC *warehouse.GetWarehouseUseCase,
        getZonesUC *warehouse.GetZonesUseCase,
        getLocationsUC *warehouse.GetLocationsUseCase,
) *WarehouseHandler <span class="cov0" title="0">{
        return &amp;WarehouseHandler{
                listWarehousesUC: listWarehousesUC,
                getWarehouseUC:   getWarehouseUC,
                getZonesUC:       getZonesUC,
                getLocationsUC:   getLocationsUC,
        }
}</span>

// ListWarehouses handles GET /warehouses
func (h *WarehouseHandler) ListWarehouses(c *gin.Context) <span class="cov0" title="0">{
        filter := &amp;repository.WarehouseFilter{
                Type:   c.Query("type"),
                Search: c.Query("search"),
                Page:   getPageParam(c),
                Limit:  getLimitParam(c),
        }

        warehouses, total, err := h.listWarehousesUC.Execute(c.Request.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.SuccessWithMeta(c, warehouses, response.NewMeta(filter.Page, filter.Limit, int64(total)))</span>
}

// GetWarehouse handles GET /warehouses/:id
func (h *WarehouseHandler) GetWarehouse(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid warehouse ID"))
                return
        }</span>

        <span class="cov0" title="0">wh, err := h.getWarehouseUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.NotFound("Warehouse"))
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, wh)</span>
}

// GetZones handles GET /warehouses/:id/zones
func (h *WarehouseHandler) GetZones(c *gin.Context) <span class="cov0" title="0">{
        warehouseID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid warehouse ID"))
                return
        }</span>

        <span class="cov0" title="0">zones, err := h.getZonesUC.Execute(c.Request.Context(), warehouseID)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, zones)</span>
}

// GetLocations handles GET /zones/:id/locations
func (h *WarehouseHandler) GetLocations(c *gin.Context) <span class="cov0" title="0">{
        zoneID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid zone ID"))
                return
        }</span>

        <span class="cov0" title="0">locations, err := h.getLocationsUC.Execute(c.Request.Context(), zoneID)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, locations)</span>
}

// StockHandler handles stock endpoints
type StockHandler struct {
        getStockUC         *stock.GetStockUseCase
        issueStockFEFOUC   *stock.IssueStockFEFOUseCase
        reserveStockUC     *stock.ReserveStockUseCase
        releaseReservationUC *stock.ReleaseReservationUseCase
}

// NewStockHandler creates a new stock handler
func NewStockHandler(
        getStockUC *stock.GetStockUseCase,
        issueStockFEFOUC *stock.IssueStockFEFOUseCase,
        reserveStockUC *stock.ReserveStockUseCase,
        releaseReservationUC *stock.ReleaseReservationUseCase,
) *StockHandler <span class="cov0" title="0">{
        return &amp;StockHandler{
                getStockUC:           getStockUC,
                issueStockFEFOUC:     issueStockFEFOUC,
                reserveStockUC:       reserveStockUC,
                releaseReservationUC: releaseReservationUC,
        }
}</span>

// ListStock handles GET /stock
func (h *StockHandler) ListStock(c *gin.Context) <span class="cov0" title="0">{
        filter := &amp;repository.StockFilter{
                Page:  getPageParam(c),
                Limit: getLimitParam(c),
        }

        if warehouseID := c.Query("warehouse_id"); warehouseID != "" </span><span class="cov0" title="0">{
                id, _ := uuid.Parse(warehouseID)
                filter.WarehouseID = &amp;id
        }</span>
        <span class="cov0" title="0">if materialID := c.Query("material_id"); materialID != "" </span><span class="cov0" title="0">{
                id, _ := uuid.Parse(materialID)
                filter.MaterialID = &amp;id
        }</span>
        <span class="cov0" title="0">if hasStock := c.Query("has_stock"); hasStock == "true" </span><span class="cov0" title="0">{
                t := true
                filter.HasStock = &amp;t
        }</span>

        <span class="cov0" title="0">stocks, total, err := h.getStockUC.Execute(c.Request.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.SuccessWithMeta(c, stocks, response.NewMeta(filter.Page, filter.Limit, int64(total)))</span>
}

// GetStockByMaterial handles GET /stock/by-material/:id
func (h *StockHandler) GetStockByMaterial(c *gin.Context) <span class="cov0" title="0">{
        materialID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid material ID"))
                return
        }</span>

        <span class="cov0" title="0">stocks, err := h.getStockUC.GetByMaterial(c.Request.Context(), materialID)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">summary, _ := h.getStockUC.GetSummary(c.Request.Context(), materialID)

        response.Success(c, gin.H{
                "stocks":  stocks,
                "summary": summary,
        })</span>
}

// GetExpiringStock handles GET /stock/expiring
func (h *StockHandler) GetExpiringStock(c *gin.Context) <span class="cov0" title="0">{
        days, _ := strconv.Atoi(c.DefaultQuery("days", "90"))

        stocks, err := h.getStockUC.GetExpiringStock(c.Request.Context(), days)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, stocks)</span>
}

// GetLowStock handles GET /stock/low-stock
func (h *StockHandler) GetLowStock(c *gin.Context) <span class="cov0" title="0">{
        threshold, _ := strconv.ParseFloat(c.DefaultQuery("threshold", "100"), 64)

        stocks, err := h.getStockUC.GetLowStock(c.Request.Context(), threshold)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, stocks)</span>
}

// LotHandler handles lot endpoints
type LotHandler struct {
        getLotUC          *lot.GetLotUseCase
        listLotsUC        *lot.ListLotsUseCase
        getExpiringLotsUC *lot.GetExpiringLotsUseCase
        getLotMovementsUC *lot.GetLotMovementsUseCase
}

// NewLotHandler creates a new lot handler
func NewLotHandler(
        getLotUC *lot.GetLotUseCase,
        listLotsUC *lot.ListLotsUseCase,
        getExpiringLotsUC *lot.GetExpiringLotsUseCase,
        getLotMovementsUC *lot.GetLotMovementsUseCase,
) *LotHandler <span class="cov0" title="0">{
        return &amp;LotHandler{
                getLotUC:          getLotUC,
                listLotsUC:        listLotsUC,
                getExpiringLotsUC: getExpiringLotsUC,
                getLotMovementsUC: getLotMovementsUC,
        }
}</span>

// ListLots handles GET /lots
func (h *LotHandler) ListLots(c *gin.Context) <span class="cov0" title="0">{
        filter := &amp;repository.LotFilter{
                Status:   c.Query("status"),
                QCStatus: c.Query("qc_status"),
                Search:   c.Query("search"),
                Page:     getPageParam(c),
                Limit:    getLimitParam(c),
        }

        if materialID := c.Query("material_id"); materialID != "" </span><span class="cov0" title="0">{
                id, _ := uuid.Parse(materialID)
                filter.MaterialID = &amp;id
        }</span>

        <span class="cov0" title="0">lots, total, err := h.listLotsUC.Execute(c.Request.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.SuccessWithMeta(c, lots, response.NewMeta(filter.Page, filter.Limit, int64(total)))</span>
}

// GetLot handles GET /lots/:id
func (h *LotHandler) GetLot(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid lot ID"))
                return
        }</span>

        <span class="cov0" title="0">l, err := h.getLotUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.NotFound("Lot"))
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, l)</span>
}

// GetLotMovements handles GET /lots/:id/movements
func (h *LotHandler) GetLotMovements(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.BadRequest("Invalid lot ID"))
                return
        }</span>

        <span class="cov0" title="0">movements, err := h.getLotMovementsUC.Execute(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, errors.Internal(err))
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, movements)</span>
}

// Helper functions
func getPageParam(c *gin.Context) int <span class="cov0" title="0">{
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">return page</span>
}

func getLimitParam(c *gin.Context) int <span class="cov0" title="0">{
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        if limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>
        <span class="cov0" title="0">return limit</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package router

import (
        "github.com/erp-cosmetics/wms-service/internal/delivery/http/handler"
        "github.com/gin-gonic/gin"
)

// SetupRouter sets up the HTTP router
func SetupRouter(
        warehouseHandler *handler.WarehouseHandler,
        stockHandler *handler.StockHandler,
        lotHandler *handler.LotHandler,
        grnHandler *handler.GRNHandler,
        issueHandler *handler.GoodsIssueHandler,
        reservationHandler *handler.ReservationHandler,
        adjustmentHandler *handler.AdjustmentHandler,
        inventoryCountHandler *handler.InventoryCountHandler,
        healthHandler *handler.HealthHandler,
) *gin.Engine <span class="cov0" title="0">{
        r := gin.New()
        r.Use(gin.Logger())
        r.Use(gin.Recovery())

        // Health endpoints
        r.GET("/health", healthHandler.Health)
        r.GET("/ready", healthHandler.Ready)
        r.GET("/live", healthHandler.Live)

        // API v1
        v1 := r.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Warehouse endpoints
                warehouses := v1.Group("/warehouses")
                </span><span class="cov0" title="0">{
                        warehouses.GET("", warehouseHandler.ListWarehouses)
                        warehouses.GET("/:id", warehouseHandler.GetWarehouse)
                        warehouses.GET("/:id/zones", warehouseHandler.GetZones)
                }</span>

                // Zone endpoints
                <span class="cov0" title="0">zones := v1.Group("/zones")
                </span><span class="cov0" title="0">{
                        zones.GET("/:id/locations", warehouseHandler.GetLocations)
                }</span>

                // Stock endpoints
                <span class="cov0" title="0">stock := v1.Group("/stock")
                </span><span class="cov0" title="0">{
                        stock.GET("", stockHandler.ListStock)
                        stock.GET("/by-material/:id", stockHandler.GetStockByMaterial)
                        stock.GET("/expiring", stockHandler.GetExpiringStock)
                        stock.GET("/low-stock", stockHandler.GetLowStock)
                        stock.GET("/availability/:material_id", reservationHandler.CheckAvailability)
                }</span>

                // Lot endpoints
                <span class="cov0" title="0">lots := v1.Group("/lots")
                </span><span class="cov0" title="0">{
                        lots.GET("", lotHandler.ListLots)
                        lots.GET("/:id", lotHandler.GetLot)
                        lots.GET("/:id/movements", lotHandler.GetLotMovements)
                }</span>

                // GRN endpoints
                <span class="cov0" title="0">grn := v1.Group("/grn")
                </span><span class="cov0" title="0">{
                        grn.POST("", grnHandler.CreateGRN)
                        grn.GET("", grnHandler.ListGRNs)
                        grn.GET("/:id", grnHandler.GetGRN)
                        grn.PATCH("/:id/complete", grnHandler.CompleteGRN)
                }</span>

                // Goods Issue endpoints
                <span class="cov0" title="0">goodsIssue := v1.Group("/goods-issue")
                </span><span class="cov0" title="0">{
                        goodsIssue.POST("", issueHandler.CreateGoodsIssue)
                        goodsIssue.GET("", issueHandler.ListGoodsIssues)
                        goodsIssue.GET("/:id", issueHandler.GetGoodsIssue)
                }</span>

                // Reservation endpoints
                <span class="cov0" title="0">reservations := v1.Group("/reservations")
                </span><span class="cov0" title="0">{
                        reservations.POST("", reservationHandler.CreateReservation)
                        reservations.DELETE("/:id", reservationHandler.ReleaseReservation)
                }</span>

                // Adjustment endpoints
                <span class="cov0" title="0">adjustments := v1.Group("/adjustments")
                </span><span class="cov0" title="0">{
                        adjustments.POST("", adjustmentHandler.CreateAdjustment)
                }</span>

                // Transfer endpoints
                <span class="cov0" title="0">transfers := v1.Group("/transfers")
                </span><span class="cov0" title="0">{
                        transfers.POST("", adjustmentHandler.TransferStock)
                }</span>

                // Inventory Count endpoints
                <span class="cov0" title="0">inventoryCounts := v1.Group("/inventory-counts")
                </span><span class="cov0" title="0">{
                        inventoryCounts.POST("", inventoryCountHandler.CreateInventoryCount)
                        inventoryCounts.GET("", inventoryCountHandler.ListInventoryCounts)
                        inventoryCounts.GET("/:id", inventoryCountHandler.GetInventoryCount)
                        inventoryCounts.PATCH("/:id/start", inventoryCountHandler.StartInventoryCount)
                        inventoryCounts.POST("/:id/record", inventoryCountHandler.RecordCount)
                        inventoryCounts.PATCH("/:id/complete", inventoryCountHandler.CompleteInventoryCount)
                }</span>
        }

        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package entity

import (
        "time"

        "github.com/google/uuid"
)

// IssueType represents the type of goods issue
type IssueType string

const (
        IssueTypeProduction  IssueType = "PRODUCTION"
        IssueTypeSales       IssueType = "SALES"
        IssueTypeSample      IssueType = "SAMPLE"
        IssueTypeScrap       IssueType = "SCRAP"
        IssueTypeAdjustment  IssueType = "ADJUSTMENT"
)

// GoodsIssueStatus represents goods issue status
type GoodsIssueStatus string

const (
        GoodsIssueStatusDraft     GoodsIssueStatus = "DRAFT"
        GoodsIssueStatusConfirmed GoodsIssueStatus = "CONFIRMED"
        GoodsIssueStatusCompleted GoodsIssueStatus = "COMPLETED"
        GoodsIssueStatusCancelled GoodsIssueStatus = "CANCELLED"
)

// GoodsIssue represents a goods issue document
type GoodsIssue struct {
        ID              uuid.UUID        `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        IssueNumber     string           `json:"issue_number" gorm:"type:varchar(30);unique;not null"` // GI-YYYY-XXXX
        IssueDate       time.Time        `json:"issue_date" gorm:"type:date;not null"`
        IssueType       IssueType        `json:"issue_type" gorm:"type:varchar(30);not null"`
        ReferenceType   ReferenceType    `json:"reference_type" gorm:"type:varchar(30)"`
        ReferenceID     *uuid.UUID       `json:"reference_id" gorm:"type:uuid"`
        ReferenceNumber string           `json:"reference_number" gorm:"type:varchar(30)"`
        WarehouseID     uuid.UUID        `json:"warehouse_id" gorm:"type:uuid;not null"`
        Status          GoodsIssueStatus `json:"status" gorm:"type:varchar(20);default:'DRAFT'"`
        Notes           string           `json:"notes" gorm:"type:text"`
        IssuedBy        *uuid.UUID       `json:"issued_by" gorm:"type:uuid"`
        CreatedAt       time.Time        `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt       time.Time        `json:"updated_at" gorm:"default:CURRENT_TIMESTAMP"`

        // Relations
        Warehouse *Warehouse       `json:"warehouse,omitempty" gorm:"foreignKey:WarehouseID"`
        LineItems []GILineItem     `json:"line_items,omitempty" gorm:"foreignKey:GoodsIssueID"`
}

// TableName returns the table name
func (GoodsIssue) TableName() string <span class="cov0" title="0">{
        return "goods_issues"
}</span>

// Confirm confirms the goods issue
func (g *GoodsIssue) Confirm() <span class="cov8" title="1">{
        g.Status = GoodsIssueStatusConfirmed
        g.UpdatedAt = time.Now()
}</span>

// Complete completes the goods issue
func (g *GoodsIssue) Complete() <span class="cov8" title="1">{
        g.Status = GoodsIssueStatusCompleted
        g.UpdatedAt = time.Now()
}</span>

// Cancel cancels the goods issue
func (g *GoodsIssue) Cancel() <span class="cov0" title="0">{
        g.Status = GoodsIssueStatusCancelled
        g.UpdatedAt = time.Now()
}</span>

// GILineItem represents a line item in goods issue
type GILineItem struct {
        ID           uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        GoodsIssueID uuid.UUID  `json:"goods_issue_id" gorm:"type:uuid;not null"`
        LineNumber   int        `json:"line_number" gorm:"not null"`
        MaterialID   uuid.UUID  `json:"material_id" gorm:"type:uuid;not null"`
        RequestedQty float64    `json:"requested_qty" gorm:"type:decimal(15,4);not null"`
        IssuedQty    float64    `json:"issued_qty" gorm:"type:decimal(15,4);not null"`
        UnitID       uuid.UUID  `json:"unit_id" gorm:"type:uuid;not null"`
        LotID        *uuid.UUID `json:"lot_id" gorm:"type:uuid"`
        LocationID   *uuid.UUID `json:"location_id" gorm:"type:uuid"`
        CreatedAt    time.Time  `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`

        // Relations
        Lot      *Lot      `json:"lot,omitempty" gorm:"foreignKey:LotID"`
        Location *Location `json:"location,omitempty" gorm:"foreignKey:LocationID"`
}

// TableName returns the table name
func (GILineItem) TableName() string <span class="cov0" title="0">{
        return "gi_line_items"
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package entity

import (
        "time"

        "github.com/google/uuid"
)

// GRNStatus represents GRN status
type GRNStatus string

const (
        GRNStatusDraft      GRNStatus = "DRAFT"
        GRNStatusInProgress GRNStatus = "IN_PROGRESS"
        GRNStatusCompleted  GRNStatus = "COMPLETED"
        GRNStatusCancelled  GRNStatus = "CANCELLED"
)

// GRN represents a Goods Receipt Note
type GRN struct {
        ID                 uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        GRNNumber          string     `json:"grn_number" gorm:"type:varchar(30);unique;not null"` // GRN-YYYY-XXXX
        GRNDate            time.Time  `json:"grn_date" gorm:"type:date;not null"`
        POID               *uuid.UUID `json:"po_id" gorm:"type:uuid"`
        PONumber           string     `json:"po_number" gorm:"type:varchar(30)"`
        SupplierID         *uuid.UUID `json:"supplier_id" gorm:"type:uuid"`
        WarehouseID        uuid.UUID  `json:"warehouse_id" gorm:"type:uuid;not null"`
        DeliveryNoteNumber string     `json:"delivery_note_number" gorm:"type:varchar(50)"`
        VehicleNumber      string     `json:"vehicle_number" gorm:"type:varchar(20)"`
        Status             GRNStatus  `json:"status" gorm:"type:varchar(20);default:'DRAFT'"`
        QCStatus           QCStatus   `json:"qc_status" gorm:"type:varchar(20);default:'PENDING'"`
        QCNotes            string     `json:"qc_notes" gorm:"type:text"`
        Notes              string     `json:"notes" gorm:"type:text"`
        ReceivedBy         *uuid.UUID `json:"received_by" gorm:"type:uuid"`
        CompletedAt        *time.Time `json:"completed_at"`
        CreatedAt          time.Time  `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt          time.Time  `json:"updated_at" gorm:"default:CURRENT_TIMESTAMP"`

        // Relations
        Warehouse *Warehouse    `json:"warehouse,omitempty" gorm:"foreignKey:WarehouseID"`
        LineItems []GRNLineItem `json:"line_items,omitempty" gorm:"foreignKey:GRNID"`
}

// TableName returns the table name
func (GRN) TableName() string <span class="cov0" title="0">{
        return "grns"
}</span>

// CanComplete returns true if GRN can be completed
func (g *GRN) CanComplete() bool <span class="cov8" title="1">{
        return g.Status == GRNStatusDraft || g.Status == GRNStatusInProgress
}</span>

// Complete completes the GRN
func (g *GRN) Complete(qcStatus QCStatus, qcNotes string) <span class="cov8" title="1">{
        now := time.Now()
        g.Status = GRNStatusCompleted
        g.QCStatus = qcStatus
        g.QCNotes = qcNotes
        g.CompletedAt = &amp;now
        g.UpdatedAt = now
}</span>

// Cancel cancels the GRN
func (g *GRN) Cancel() <span class="cov8" title="1">{
        g.Status = GRNStatusCancelled
        g.UpdatedAt = time.Now()
}</span>

// StartProcessing starts processing the GRN
func (g *GRN) StartProcessing() <span class="cov0" title="0">{
        g.Status = GRNStatusInProgress
        g.UpdatedAt = time.Now()
}</span>

// GRNLineItem represents a line item in GRN
type GRNLineItem struct {
        ID                uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        GRNID             uuid.UUID  `json:"grn_id" gorm:"type:uuid;not null"`
        LineNumber        int        `json:"line_number" gorm:"not null"`
        POLineItemID      *uuid.UUID `json:"po_line_item_id" gorm:"type:uuid"`
        MaterialID        uuid.UUID  `json:"material_id" gorm:"type:uuid;not null"`
        ExpectedQty       *float64   `json:"expected_qty" gorm:"type:decimal(15,4)"`
        ReceivedQty       float64    `json:"received_qty" gorm:"type:decimal(15,4);not null"`
        AcceptedQty       *float64   `json:"accepted_qty" gorm:"type:decimal(15,4)"`
        RejectedQty       float64    `json:"rejected_qty" gorm:"type:decimal(15,4);default:0"`
        UnitID            uuid.UUID  `json:"unit_id" gorm:"type:uuid;not null"`
        LotID             *uuid.UUID `json:"lot_id" gorm:"type:uuid"`
        SupplierLotNumber string     `json:"supplier_lot_number" gorm:"type:varchar(50)"`
        ManufacturedDate  *time.Time `json:"manufactured_date" gorm:"type:date"`
        ExpiryDate        time.Time  `json:"expiry_date" gorm:"type:date;not null"`
        LocationID        *uuid.UUID `json:"location_id" gorm:"type:uuid"`
        QCStatus          QCStatus   `json:"qc_status" gorm:"type:varchar(20);default:'PENDING'"`
        QCNotes           string     `json:"qc_notes" gorm:"type:text"`
        CreatedAt         time.Time  `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`

        // Relations
        Lot      *Lot      `json:"lot,omitempty" gorm:"foreignKey:LotID"`
        Location *Location `json:"location,omitempty" gorm:"foreignKey:LocationID"`
}

// TableName returns the table name
func (GRNLineItem) TableName() string <span class="cov0" title="0">{
        return "grn_line_items"
}</span>

// PassQC passes QC for the line item
func (i *GRNLineItem) PassQC(acceptedQty float64) <span class="cov8" title="1">{
        i.QCStatus = QCStatusPassed
        i.AcceptedQty = &amp;acceptedQty
        i.RejectedQty = i.ReceivedQty - acceptedQty
}</span>

// FailQC fails QC for the line item
func (i *GRNLineItem) FailQC(notes string) <span class="cov8" title="1">{
        i.QCStatus = QCStatusFailed
        rejected := i.ReceivedQty
        i.RejectedQty = rejected
        zero := 0.0
        i.AcceptedQty = &amp;zero
        i.QCNotes = notes
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package entity

import (
        "time"

        "github.com/google/uuid"
)

// InventoryCountStatus represents the status of inventory count
type InventoryCountStatus string

const (
        InventoryCountStatusDraft      InventoryCountStatus = "DRAFT"
        InventoryCountStatusInProgress InventoryCountStatus = "IN_PROGRESS"
        InventoryCountStatusCompleted  InventoryCountStatus = "COMPLETED"
        InventoryCountStatusCancelled  InventoryCountStatus = "CANCELLED"
)

// InventoryCountType represents the type of count
type InventoryCountType string

const (
        InventoryCountTypeFull   InventoryCountType = "FULL"
        InventoryCountTypeCycle  InventoryCountType = "CYCLE"
        InventoryCountTypeSpot   InventoryCountType = "SPOT"
)

// InventoryCount represents a physical inventory count
type InventoryCount struct {
        ID            uuid.UUID            `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        CountNumber   string               `json:"count_number" gorm:"type:varchar(30);uniqueIndex;not null"`
        CountDate     time.Time            `json:"count_date" gorm:"type:date;not null"`
        CountType     InventoryCountType   `json:"count_type" gorm:"type:varchar(20);not null"`
        WarehouseID   uuid.UUID            `json:"warehouse_id" gorm:"type:uuid;not null"`
        ZoneID        *uuid.UUID           `json:"zone_id" gorm:"type:uuid"`
        Status        InventoryCountStatus `json:"status" gorm:"type:varchar(20);default:'DRAFT'"`
        Notes         string               `json:"notes" gorm:"type:text"`
        StartedAt     *time.Time           `json:"started_at"`
        CompletedAt   *time.Time           `json:"completed_at"`
        CreatedBy     uuid.UUID            `json:"created_by" gorm:"type:uuid;not null"`
        ApprovedBy    *uuid.UUID           `json:"approved_by" gorm:"type:uuid"`
        CreatedAt     time.Time            `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt     time.Time            `json:"updated_at" gorm:"default:CURRENT_TIMESTAMP"`

        // Relations
        Warehouse *Warehouse               `json:"warehouse,omitempty" gorm:"foreignKey:WarehouseID"`
        Zone      *Zone                    `json:"zone,omitempty" gorm:"foreignKey:ZoneID"`
        LineItems []InventoryCountLineItem `json:"line_items,omitempty" gorm:"foreignKey:InventoryCountID"`
}

// TableName returns the table name
func (InventoryCount) TableName() string <span class="cov0" title="0">{
        return "inventory_counts"
}</span>

// InventoryCountLineItem represents a line item in inventory count
type InventoryCountLineItem struct {
        ID               uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        InventoryCountID uuid.UUID  `json:"inventory_count_id" gorm:"type:uuid;not null"`
        LocationID       uuid.UUID  `json:"location_id" gorm:"type:uuid;not null"`
        MaterialID       uuid.UUID  `json:"material_id" gorm:"type:uuid;not null"`
        LotID            *uuid.UUID `json:"lot_id" gorm:"type:uuid"`
        UnitID           uuid.UUID  `json:"unit_id" gorm:"type:uuid;not null"`
        SystemQty        float64    `json:"system_qty" gorm:"type:decimal(15,4);not null"`
        CountedQty       *float64   `json:"counted_qty" gorm:"type:decimal(15,4)"`
        Variance         float64    `json:"variance" gorm:"type:decimal(15,4);default:0"`
        VariancePercent  float64    `json:"variance_percent" gorm:"type:decimal(8,4);default:0"`
        IsCounted        bool       `json:"is_counted" gorm:"default:false"`
        CountedBy        *uuid.UUID `json:"counted_by" gorm:"type:uuid"`
        CountedAt        *time.Time `json:"counted_at"`
        Notes            string     `json:"notes" gorm:"type:text"`
        CreatedAt        time.Time  `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`

        // Relations
        Location *Location `json:"location,omitempty" gorm:"foreignKey:LocationID"`
        Lot      *Lot      `json:"lot,omitempty" gorm:"foreignKey:LotID"`
}

// TableName returns the table name
func (InventoryCountLineItem) TableName() string <span class="cov0" title="0">{
        return "inventory_count_lines"
}</span>

// Start starts the inventory count
func (ic *InventoryCount) Start() <span class="cov8" title="1">{
        now := time.Now()
        ic.Status = InventoryCountStatusInProgress
        ic.StartedAt = &amp;now
        ic.UpdatedAt = now
}</span>

// Complete completes the inventory count
func (ic *InventoryCount) Complete(approvedBy uuid.UUID) <span class="cov8" title="1">{
        now := time.Now()
        ic.Status = InventoryCountStatusCompleted
        ic.CompletedAt = &amp;now
        ic.ApprovedBy = &amp;approvedBy
        ic.UpdatedAt = now
}</span>

// Cancel cancels the inventory count
func (ic *InventoryCount) Cancel() <span class="cov0" title="0">{
        ic.Status = InventoryCountStatusCancelled
        ic.UpdatedAt = time.Now()
}</span>

// CanStart checks if count can be started
func (ic *InventoryCount) CanStart() bool <span class="cov8" title="1">{
        return ic.Status == InventoryCountStatusDraft
}</span>

// CanComplete checks if count can be completed
func (ic *InventoryCount) CanComplete() bool <span class="cov8" title="1">{
        return ic.Status == InventoryCountStatusInProgress
}</span>

// RecordCount records the counted quantity
func (li *InventoryCountLineItem) RecordCount(countedQty float64, countedBy uuid.UUID) <span class="cov8" title="1">{
        now := time.Now()
        li.CountedQty = &amp;countedQty
        li.Variance = countedQty - li.SystemQty
        if li.SystemQty &gt; 0 </span><span class="cov8" title="1">{
                li.VariancePercent = (li.Variance / li.SystemQty) * 100
        }</span>
        <span class="cov8" title="1">li.IsCounted = true
        li.CountedBy = &amp;countedBy
        li.CountedAt = &amp;now</span>
}

// HasVariance checks if there's a variance
func (li *InventoryCountLineItem) HasVariance() bool <span class="cov8" title="1">{
        return li.Variance != 0
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package entity

import (
        "time"

        "github.com/google/uuid"
)

// Location represents a storage location within a zone
type Location struct {
        ID        uuid.UUID `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        ZoneID    uuid.UUID `json:"zone_id" gorm:"type:uuid;not null"`
        Code      string    `json:"code" gorm:"type:varchar(30);not null"` // A01-R02-S03-B01
        Aisle     string    `json:"aisle" gorm:"type:varchar(10)"`
        Rack      string    `json:"rack" gorm:"type:varchar(10)"`
        Shelf     string    `json:"shelf" gorm:"type:varchar(10)"`
        Bin       string    `json:"bin" gorm:"type:varchar(10)"`
        Capacity  *float64  `json:"capacity" gorm:"type:decimal(10,2)"`
        IsActive  bool      `json:"is_active" gorm:"default:true"`
        CreatedAt time.Time `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt time.Time `json:"updated_at" gorm:"default:CURRENT_TIMESTAMP"`

        // Relations
        Zone *Zone `json:"zone,omitempty" gorm:"foreignKey:ZoneID"`
}

// TableName returns the table name
func (Location) TableName() string <span class="cov0" title="0">{
        return "locations"
}</span>

// GetFullPath returns the full location path including warehouse and zone
func (l *Location) GetFullPath() string <span class="cov0" title="0">{
        if l.Zone == nil || l.Zone.Warehouse == nil </span><span class="cov0" title="0">{
                return l.Code
        }</span>
        <span class="cov0" title="0">return l.Zone.Warehouse.Code + "/" + l.Zone.Code + "/" + l.Code</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package entity

import (
        "time"

        "github.com/google/uuid"
)

// QCStatus represents QC status
type QCStatus string

const (
        QCStatusPending    QCStatus = "PENDING"
        QCStatusPassed     QCStatus = "PASSED"
        QCStatusFailed     QCStatus = "FAILED"
        QCStatusQuarantine QCStatus = "QUARANTINE"
)

// LotStatus represents lot status
type LotStatus string

const (
        LotStatusAvailable LotStatus = "AVAILABLE"
        LotStatusReserved  LotStatus = "RESERVED"
        LotStatusBlocked   LotStatus = "BLOCKED"
        LotStatusExpired   LotStatus = "EXPIRED"
)

// Lot represents a lot/batch of material - CRITICAL for FEFO
type Lot struct {
        ID                uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        LotNumber         string     `json:"lot_number" gorm:"type:varchar(30);unique;not null"` // LOT-YYYYMM-XXXX
        MaterialID        uuid.UUID  `json:"material_id" gorm:"type:uuid;not null"`
        SupplierID        *uuid.UUID `json:"supplier_id" gorm:"type:uuid"`
        SupplierLotNumber string     `json:"supplier_lot_number" gorm:"type:varchar(50)"`
        ManufacturedDate  *time.Time `json:"manufactured_date" gorm:"type:date"`
        ExpiryDate        time.Time  `json:"expiry_date" gorm:"type:date;not null"` // Critical for FEFO
        ReceivedDate      time.Time  `json:"received_date" gorm:"type:date;not null"`
        GRNID             *uuid.UUID `json:"grn_id" gorm:"type:uuid"`
        QCStatus          QCStatus   `json:"qc_status" gorm:"type:varchar(20);default:'PENDING'"`
        Status            LotStatus  `json:"status" gorm:"type:varchar(20);default:'AVAILABLE'"`
        Notes             string     `json:"notes" gorm:"type:text"`
        CreatedAt         time.Time  `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt         time.Time  `json:"updated_at" gorm:"default:CURRENT_TIMESTAMP"`
}

// TableName returns the table name
func (Lot) TableName() string <span class="cov0" title="0">{
        return "lots"
}</span>

// DaysUntilExpiry returns the number of days until expiry
func (l *Lot) DaysUntilExpiry() int <span class="cov8" title="1">{
        duration := time.Until(l.ExpiryDate)
        return int(duration.Hours() / 24)
}</span>

// IsExpired returns true if the lot is expired
func (l *Lot) IsExpired() bool <span class="cov8" title="1">{
        return time.Now().After(l.ExpiryDate)
}</span>

// IsExpiringSoon returns true if the lot expires within the given days
func (l *Lot) IsExpiringSoon(days int) bool <span class="cov8" title="1">{
        threshold := time.Now().AddDate(0, 0, days)
        return l.ExpiryDate.Before(threshold) &amp;&amp; !l.IsExpired()
}</span>

// MarkExpired marks the lot as expired
func (l *Lot) MarkExpired() <span class="cov0" title="0">{
        l.Status = LotStatusExpired
        l.UpdatedAt = time.Now()
}</span>

// PassQC marks the lot as QC passed
func (l *Lot) PassQC() <span class="cov8" title="1">{
        l.QCStatus = QCStatusPassed
        l.Status = LotStatusAvailable
        l.UpdatedAt = time.Now()
}</span>

// FailQC marks the lot as QC failed
func (l *Lot) FailQC() <span class="cov8" title="1">{
        l.QCStatus = QCStatusFailed
        l.Status = LotStatusBlocked
        l.UpdatedAt = time.Now()
}</span>

// CanBeIssued returns true if the lot can be issued
func (l *Lot) CanBeIssued() bool <span class="cov8" title="1">{
        return l.Status == LotStatusAvailable &amp;&amp; 
                l.QCStatus == QCStatusPassed &amp;&amp; 
                !l.IsExpired()
}</span>

// Block blocks the lot
func (l *Lot) Block() <span class="cov0" title="0">{
        l.Status = LotStatusBlocked
        l.UpdatedAt = time.Now()
}</span>

// Unblock unblocks the lot
func (l *Lot) Unblock() <span class="cov0" title="0">{
        if l.QCStatus == QCStatusPassed &amp;&amp; !l.IsExpired() </span><span class="cov0" title="0">{
                l.Status = LotStatusAvailable
        }</span>
        <span class="cov0" title="0">l.UpdatedAt = time.Now()</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package entity

import (
        "time"

        "github.com/google/uuid"
)

// Stock represents stock at a specific location with lot
type Stock struct {
        ID           uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        WarehouseID  uuid.UUID  `json:"warehouse_id" gorm:"type:uuid;not null"`
        ZoneID       uuid.UUID  `json:"zone_id" gorm:"type:uuid;not null"`
        LocationID   uuid.UUID  `json:"location_id" gorm:"type:uuid;not null"`
        MaterialID   uuid.UUID  `json:"material_id" gorm:"type:uuid;not null"`
        LotID        *uuid.UUID `json:"lot_id" gorm:"type:uuid"`
        Quantity     float64    `json:"quantity" gorm:"type:decimal(15,4);not null;default:0"`
        ReservedQty  float64    `json:"reserved_qty" gorm:"type:decimal(15,4);not null;default:0"`
        AvailableQty float64    `json:"available_qty" gorm:"type:decimal(15,4)"` // Computed: Quantity - ReservedQty
        UnitID       uuid.UUID  `json:"unit_id" gorm:"type:uuid;not null"`
        CreatedAt    time.Time  `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt    time.Time  `json:"updated_at" gorm:"default:CURRENT_TIMESTAMP"`

        // Relations
        Warehouse *Warehouse `json:"warehouse,omitempty" gorm:"foreignKey:WarehouseID"`
        Zone      *Zone      `json:"zone,omitempty" gorm:"foreignKey:ZoneID"`
        Location  *Location  `json:"location,omitempty" gorm:"foreignKey:LocationID"`
        Lot       *Lot       `json:"lot,omitempty" gorm:"foreignKey:LotID"`
}

// TableName returns the table name
func (Stock) TableName() string <span class="cov0" title="0">{
        return "stock"
}</span>

// GetAvailableQuantity returns available quantity (quantity - reserved)
func (s *Stock) GetAvailableQuantity() float64 <span class="cov8" title="1">{
        return s.Quantity - s.ReservedQty
}</span>

// CanIssue returns true if quantity can be issued
func (s *Stock) CanIssue(qty float64) bool <span class="cov8" title="1">{
        return s.GetAvailableQuantity() &gt;= qty
}</span>

// Reserve reserves stock
func (s *Stock) Reserve(qty float64) error <span class="cov8" title="1">{
        if !s.CanIssue(qty) </span><span class="cov8" title="1">{
                return ErrInsufficientStock
        }</span>
        <span class="cov8" title="1">s.ReservedQty += qty
        s.AvailableQty = s.GetAvailableQuantity()
        s.UpdatedAt = time.Now()
        return nil</span>
}

// ReleaseReservation releases reserved stock
func (s *Stock) ReleaseReservation(qty float64) <span class="cov8" title="1">{
        s.ReservedQty -= qty
        if s.ReservedQty &lt; 0 </span><span class="cov8" title="1">{
                s.ReservedQty = 0
        }</span>
        <span class="cov8" title="1">s.AvailableQty = s.GetAvailableQuantity()
        s.UpdatedAt = time.Now()</span>
}

// Issue issues stock (deduct quantity)
func (s *Stock) Issue(qty float64) error <span class="cov8" title="1">{
        if s.Quantity &lt; qty </span><span class="cov8" title="1">{
                return ErrInsufficientStock
        }</span>
        <span class="cov8" title="1">s.Quantity -= qty
        s.AvailableQty = s.GetAvailableQuantity()
        s.UpdatedAt = time.Now()
        return nil</span>
}

// Receive adds stock
func (s *Stock) Receive(qty float64) <span class="cov8" title="1">{
        s.Quantity += qty
        s.AvailableQty = s.GetAvailableQuantity()
        s.UpdatedAt = time.Now()
}</span>

// LotIssued represents a lot that was issued (for FEFO tracking)
type LotIssued struct {
        LotID      uuid.UUID `json:"lot_id"`
        LotNumber  string    `json:"lot_number"`
        Quantity   float64   `json:"quantity"`
        ExpiryDate time.Time `json:"expiry_date"`
        LocationID uuid.UUID `json:"location_id"`
}

// StockSummary represents aggregated stock summary
type StockSummary struct {
        MaterialID    uuid.UUID `json:"material_id"`
        MaterialCode  string    `json:"material_code"`
        MaterialName  string    `json:"material_name"`
        TotalQuantity float64   `json:"total_quantity"`
        TotalReserved float64   `json:"total_reserved"`
        TotalAvailable float64  `json:"total_available"`
        UnitCode      string    `json:"unit_code"`
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package entity

import (
        "math"
        "time"
)

// AllocateStockFEFO implements the core FEFO allocation logic.
// It takes a list of available stocks (already filtered and sorted by expiry)
// and returns the lots to be issued and the remaining quantity.
func AllocateStockFEFO(stocks []*Stock, quantity float64) ([]LotIssued, float64, error) <span class="cov8" title="1">{
        remaining := quantity
        var issued []LotIssued

        for _, stock := range stocks </span><span class="cov8" title="1">{
                if remaining &lt;= 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">availableQty := stock.Quantity - stock.ReservedQty
                if availableQty &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">issueQty := math.Min(availableQty, remaining)

                // Record the issued lot
                if stock.Lot != nil </span><span class="cov8" title="1">{
                        issued = append(issued, LotIssued{
                                LotID:      stock.Lot.ID,
                                LotNumber:  stock.Lot.LotNumber,
                                Quantity:   issueQty,
                                ExpiryDate: stock.Lot.ExpiryDate,
                                LocationID: stock.LocationID,
                        })
                }</span> else<span class="cov0" title="0"> if stock.LotID != nil </span><span class="cov0" title="0">{
                        issued = append(issued, LotIssued{
                                LotID:      *stock.LotID,
                                LotNumber:  "", // Unknown if Lot object is missing
                                Quantity:   issueQty,
                                LocationID: stock.LocationID,
                        })
                }</span>

                <span class="cov8" title="1">remaining -= issueQty</span>
        }

        <span class="cov8" title="1">return issued, remaining, nil</span>
}

// FilterAndSortForFEFO filters and sorts a given list of stocks for FEFO allocation.
// Stocks must have MaterialID, Quantity &gt; ReservedQty, Lot must be Available, QC Passed, and Not Expired.
func FilterAndSortForFEFO(stocks []*Stock, now time.Time) []*Stock <span class="cov8" title="1">{
        var filtered []*Stock

        for _, s := range stocks </span><span class="cov8" title="1">{
                if s.Lot == nil || !s.Lot.CanBeIssued() </span><span class="cov8" title="1">{
                        continue</span>
                }
                
                // Ensure it's not actually expired based on provided 'now'
                <span class="cov8" title="1">if s.Lot.ExpiryDate.Before(now) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if s.Quantity-s.ReservedQty &gt; 0 </span><span class="cov8" title="1">{
                        filtered = append(filtered, s)
                }</span>
        }

        // In a real implementation, we would sort by ExpiryDate ASC here.
        // But let's assume the caller provides them sorted or we sort them here.
        // Sorting logic:
        <span class="cov8" title="1">sortStocksByExpiry(filtered)

        return filtered</span>
}

func sortStocksByExpiry(stocks []*Stock) <span class="cov8" title="1">{
        for i := 0; i &lt; len(stocks); i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(stocks); j++ </span><span class="cov0" title="0">{
                        if stocks[i].Lot.ExpiryDate.After(stocks[j].Lot.ExpiryDate) </span><span class="cov0" title="0">{
                                stocks[i], stocks[j] = stocks[j], stocks[i]
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package entity

import (
        "time"

        "github.com/google/uuid"
)

// MovementType represents the type of stock movement
type MovementType string

const (
        MovementTypeIn         MovementType = "IN"
        MovementTypeOut        MovementType = "OUT"
        MovementTypeTransfer   MovementType = "TRANSFER"
        MovementTypeAdjustment MovementType = "ADJUSTMENT"
)

// ReferenceType represents the reference type for movement
type ReferenceType string

const (
        ReferenceTypeGRN         ReferenceType = "GRN"
        ReferenceTypeGI          ReferenceType = "GI"
        ReferenceTypeWO          ReferenceType = "WO"
        ReferenceTypeTransfer    ReferenceType = "TRANSFER"
        ReferenceTypeAdjustment  ReferenceType = "ADJUSTMENT"
        ReferenceTypeReservation ReferenceType = "RESERVATION"
)

// StockMovement represents a stock movement transaction
type StockMovement struct {
        ID             uuid.UUID     `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        MovementNumber string        `json:"movement_number" gorm:"type:varchar(30);not null"`
        MovementType   MovementType  `json:"movement_type" gorm:"type:varchar(20);not null"`
        ReferenceType  ReferenceType `json:"reference_type" gorm:"type:varchar(30)"`
        ReferenceID    *uuid.UUID    `json:"reference_id" gorm:"type:uuid"`
        MaterialID     uuid.UUID     `json:"material_id" gorm:"type:uuid;not null"`
        LotID          *uuid.UUID    `json:"lot_id" gorm:"type:uuid"`
        FromLocationID *uuid.UUID    `json:"from_location_id" gorm:"type:uuid"`
        ToLocationID   *uuid.UUID    `json:"to_location_id" gorm:"type:uuid"`
        Quantity       float64       `json:"quantity" gorm:"type:decimal(15,4);not null"`
        UnitID         uuid.UUID     `json:"unit_id" gorm:"type:uuid;not null"`
        Notes          string        `json:"notes" gorm:"type:text"`
        CreatedBy      uuid.UUID     `json:"created_by" gorm:"type:uuid;not null"`
        CreatedAt      time.Time     `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`

        // Relations
        Lot          *Lot      `json:"lot,omitempty" gorm:"foreignKey:LotID"`
        FromLocation *Location `json:"from_location,omitempty" gorm:"foreignKey:FromLocationID"`
        ToLocation   *Location `json:"to_location,omitempty" gorm:"foreignKey:ToLocationID"`
}

// TableName returns the table name
func (StockMovement) TableName() string <span class="cov0" title="0">{
        return "stock_movements"
}</span>

// NewStockMovementIn creates an IN movement
func NewStockMovementIn(materialID, lotID, locationID, unitID, createdBy uuid.UUID, qty float64, refType ReferenceType, refID *uuid.UUID, movementNumber string) *StockMovement <span class="cov8" title="1">{
        return &amp;StockMovement{
                MovementNumber: movementNumber,
                MovementType:   MovementTypeIn,
                ReferenceType:  refType,
                ReferenceID:    refID,
                MaterialID:     materialID,
                LotID:          &amp;lotID,
                ToLocationID:   &amp;locationID,
                Quantity:       qty,
                UnitID:         unitID,
                CreatedBy:      createdBy,
                CreatedAt:      time.Now(),
        }
}</span>

// NewStockMovementOut creates an OUT movement
func NewStockMovementOut(materialID uuid.UUID, lotID, locationID *uuid.UUID, unitID, createdBy uuid.UUID, qty float64, refType ReferenceType, refID *uuid.UUID, movementNumber string) *StockMovement <span class="cov8" title="1">{
        return &amp;StockMovement{
                MovementNumber: movementNumber,
                MovementType:   MovementTypeOut,
                ReferenceType:  refType,
                ReferenceID:    refID,
                MaterialID:     materialID,
                LotID:          lotID,
                FromLocationID: locationID,
                Quantity:       qty,
                UnitID:         unitID,
                CreatedBy:      createdBy,
                CreatedAt:      time.Now(),
        }
}</span>

// NewStockMovementTransfer creates a TRANSFER movement
func NewStockMovementTransfer(materialID uuid.UUID, lotID *uuid.UUID, fromLocationID, toLocationID, unitID, createdBy uuid.UUID, qty float64, movementNumber string) *StockMovement <span class="cov8" title="1">{
        return &amp;StockMovement{
                MovementNumber: movementNumber,
                MovementType:   MovementTypeTransfer,
                ReferenceType:  ReferenceTypeTransfer,
                MaterialID:     materialID,
                LotID:          lotID,
                FromLocationID: &amp;fromLocationID,
                ToLocationID:   &amp;toLocationID,
                Quantity:       qty,
                UnitID:         unitID,
                CreatedBy:      createdBy,
                CreatedAt:      time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package entity

import (
        "time"

        "github.com/google/uuid"
)

// ReservationType represents the type of reservation
type ReservationType string

const (
        ReservationTypeSalesOrder ReservationType = "SALES_ORDER"
        ReservationTypeWorkOrder  ReservationType = "WORK_ORDER"
        ReservationTypeTransfer   ReservationType = "TRANSFER"
)

// ReservationStatus represents the status of reservation
type ReservationStatus string

const (
        ReservationStatusActive    ReservationStatus = "ACTIVE"
        ReservationStatusReleased  ReservationStatus = "RELEASED"
        ReservationStatusFulfilled ReservationStatus = "FULFILLED"
        ReservationStatusExpired   ReservationStatus = "EXPIRED"
)

// StockReservation represents a stock reservation
type StockReservation struct {
        ID              uuid.UUID         `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        MaterialID      uuid.UUID         `json:"material_id" gorm:"type:uuid;not null"`
        LotID           *uuid.UUID        `json:"lot_id" gorm:"type:uuid"`
        LocationID      *uuid.UUID        `json:"location_id" gorm:"type:uuid"`
        Quantity        float64           `json:"quantity" gorm:"type:decimal(15,4);not null"`
        UnitID          uuid.UUID         `json:"unit_id" gorm:"type:uuid;not null"`
        ReservationType ReservationType   `json:"reservation_type" gorm:"type:varchar(30);not null"`
        ReferenceID     uuid.UUID         `json:"reference_id" gorm:"type:uuid;not null"`
        ReferenceNumber string            `json:"reference_number" gorm:"type:varchar(30)"`
        Status          ReservationStatus `json:"status" gorm:"type:varchar(20);default:'ACTIVE'"`
        ExpiresAt       *time.Time        `json:"expires_at"`
        CreatedBy       uuid.UUID         `json:"created_by" gorm:"type:uuid;not null"`
        CreatedAt       time.Time         `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`
        ReleasedAt      *time.Time        `json:"released_at"`

        // Relations
        Lot      *Lot      `json:"lot,omitempty" gorm:"foreignKey:LotID"`
        Location *Location `json:"location,omitempty" gorm:"foreignKey:LocationID"`
}

// TableName returns the table name
func (StockReservation) TableName() string <span class="cov0" title="0">{
        return "stock_reservations"
}</span>

// IsActive returns true if reservation is active
func (r *StockReservation) IsActive() bool <span class="cov8" title="1">{
        return r.Status == ReservationStatusActive
}</span>

// IsExpired returns true if reservation is expired
func (r *StockReservation) IsExpired() bool <span class="cov8" title="1">{
        if r.ExpiresAt == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return time.Now().After(*r.ExpiresAt)</span>
}

// Release releases the reservation
func (r *StockReservation) Release() <span class="cov8" title="1">{
        now := time.Now()
        r.Status = ReservationStatusReleased
        r.ReleasedAt = &amp;now
}</span>

// Fulfill marks reservation as fulfilled
func (r *StockReservation) Fulfill() <span class="cov8" title="1">{
        now := time.Now()
        r.Status = ReservationStatusFulfilled
        r.ReleasedAt = &amp;now
}</span>

// MarkExpired marks reservation as expired
func (r *StockReservation) MarkExpired() <span class="cov0" title="0">{
        r.Status = ReservationStatusExpired
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package entity

import (
        "time"

        "github.com/google/uuid"
)

// WarehouseType represents the type of warehouse
type WarehouseType string

const (
        WarehouseTypeMain          WarehouseType = "MAIN"
        WarehouseTypeColdStorage   WarehouseType = "COLD_STORAGE"
        WarehouseTypeFinishedGoods WarehouseType = "FINISHED_GOODS"
        WarehouseTypeQuarantine    WarehouseType = "QUARANTINE"
)

// Warehouse represents a warehouse entity
type Warehouse struct {
        ID            uuid.UUID     `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        Code          string        `json:"code" gorm:"type:varchar(20);unique;not null"`
        Name          string        `json:"name" gorm:"type:varchar(100);not null"`
        WarehouseType WarehouseType `json:"warehouse_type" gorm:"type:varchar(20);not null"`
        Address       string        `json:"address" gorm:"type:text"`
        IsActive      bool          `json:"is_active" gorm:"default:true"`
        CreatedAt     time.Time     `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt     time.Time     `json:"updated_at" gorm:"default:CURRENT_TIMESTAMP"`

        // Relations
        Zones []Zone `json:"zones,omitempty" gorm:"foreignKey:WarehouseID"`
}

// TableName returns the table name
func (Warehouse) TableName() string <span class="cov0" title="0">{
        return "warehouses"
}</span>

// ZoneType represents the type of zone
type ZoneType string

const (
        ZoneTypeReceiving  ZoneType = "RECEIVING"
        ZoneTypeQuarantine ZoneType = "QUARANTINE"
        ZoneTypeStorage    ZoneType = "STORAGE"
        ZoneTypeCold       ZoneType = "COLD"
        ZoneTypePicking    ZoneType = "PICKING"
        ZoneTypeShipping   ZoneType = "SHIPPING"
)

// Zone represents a zone within a warehouse
type Zone struct {
        ID             uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
        WarehouseID    uuid.UUID  `json:"warehouse_id" gorm:"type:uuid;not null"`
        Code           string     `json:"code" gorm:"type:varchar(20);not null"`
        Name           string     `json:"name" gorm:"type:varchar(100);not null"`
        ZoneType       ZoneType   `json:"zone_type" gorm:"type:varchar(30);not null"`
        TemperatureMin *float64   `json:"temperature_min" gorm:"type:decimal(5,2)"`
        TemperatureMax *float64   `json:"temperature_max" gorm:"type:decimal(5,2)"`
        IsActive       bool       `json:"is_active" gorm:"default:true"`
        CreatedAt      time.Time  `json:"created_at" gorm:"default:CURRENT_TIMESTAMP"`
        UpdatedAt      time.Time  `json:"updated_at" gorm:"default:CURRENT_TIMESTAMP"`

        // Relations
        Warehouse *Warehouse `json:"warehouse,omitempty" gorm:"foreignKey:WarehouseID"`
        Locations []Location `json:"locations,omitempty" gorm:"foreignKey:ZoneID"`
}

// TableName returns the table name
func (Zone) TableName() string <span class="cov0" title="0">{
        return "zones"
}</span>

// IsColdZone returns true if zone requires temperature control
func (z *Zone) IsColdZone() bool <span class="cov0" title="0">{
        return z.ZoneType == ZoneTypeCold
}</span>

// IsQuarantineZone returns true if zone is quarantine
func (z *Zone) IsQuarantineZone() bool <span class="cov0" title="0">{
        return z.ZoneType == ZoneTypeQuarantine
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package event

import (
        "encoding/json"

        "github.com/erp-cosmetics/shared/pkg/nats"
        "go.uber.org/zap"
)

// Publisher handles event publishing
type Publisher struct {
        client *nats.Client
        logger *zap.Logger
}

// NewPublisher creates a new event publisher
func NewPublisher(client *nats.Client, logger *zap.Logger) *Publisher <span class="cov0" title="0">{
        return &amp;Publisher{
                client: client,
                logger: logger,
        }
}</span>

// Event subjects
const (
        SubjectGRNCreated      = "wms.grn.created"
        SubjectGRNCompleted    = "wms.grn.completed"
        SubjectStockReceived   = "wms.stock.received"
        SubjectStockIssued     = "wms.stock.issued"
        SubjectStockReserved   = "wms.stock.reserved"
        SubjectLowStockAlert   = "wms.stock.low_stock_alert"
        SubjectLotExpiringSoon = "wms.lot.expiring_soon"
        SubjectLotExpired      = "wms.lot.expired"
)

// GRNCreatedEvent represents GRN created event
type GRNCreatedEvent struct {
        GRNID     string `json:"grn_id"`
        GRNNumber string `json:"grn_number"`
        POID      string `json:"po_id,omitempty"`
}

// GRNCompletedEvent represents GRN completed event
type GRNCompletedEvent struct {
        GRNID       string                  `json:"grn_id"`
        GRNNumber   string                  `json:"grn_number"`
        POID        string                  `json:"po_id,omitempty"`
        WarehouseID string                  `json:"warehouse_id"`
        Items       []GRNCompletedEventItem `json:"items"`
}

// GRNCompletedEventItem represents an item in GRN completed event
type GRNCompletedEventItem struct {
        MaterialID   string  `json:"material_id"`
        LotID        string  `json:"lot_id"`
        LotNumber    string  `json:"lot_number"`
        ReceivedQty  float64 `json:"received_qty"`
        AcceptedQty  float64 `json:"accepted_qty"`
}

// StockReceivedEvent represents stock received event
type StockReceivedEvent struct {
        MaterialID  string  `json:"material_id"`
        LotID       string  `json:"lot_id"`
        Quantity    float64 `json:"quantity"`
        LocationID  string  `json:"location_id"`
        WarehouseID string  `json:"warehouse_id"`
}

// StockIssuedEvent represents stock issued event
type StockIssuedEvent struct {
        MaterialID    string           `json:"material_id"`
        Quantity      float64          `json:"quantity"`
        LotsUsed      []LotUsedInIssue `json:"lots_used"`
        ReferenceType string           `json:"reference_type"`
        ReferenceID   string           `json:"reference_id"`
}

// LotUsedInIssue represents a lot used in an issue
type LotUsedInIssue struct {
        LotID      string  `json:"lot_id"`
        LotNumber  string  `json:"lot_number"`
        Quantity   float64 `json:"quantity"`
        ExpiryDate string  `json:"expiry_date"`
}

// StockReservedEvent represents stock reserved event
type StockReservedEvent struct {
        ReservationID   string  `json:"reservation_id"`
        MaterialID      string  `json:"material_id"`
        Quantity        float64 `json:"quantity"`
        ReservationType string  `json:"reservation_type"`
        ReferenceID     string  `json:"reference_id"`
}

// LowStockAlertEvent represents low stock alert event
type LowStockAlertEvent struct {
        MaterialID      string  `json:"material_id"`
        MaterialCode    string  `json:"material_code"`
        CurrentQuantity float64 `json:"current_quantity"`
        ReorderPoint    float64 `json:"reorder_point"`
}

// LotExpiringEvent represents lot expiring event
type LotExpiringEvent struct {
        LotID           string  `json:"lot_id"`
        LotNumber       string  `json:"lot_number"`
        MaterialID      string  `json:"material_id"`
        ExpiryDate      string  `json:"expiry_date"`
        DaysUntilExpiry int     `json:"days_until_expiry"`
        Quantity        float64 `json:"quantity"`
}

// PublishGRNCreated publishes GRN created event
func (p *Publisher) PublishGRNCreated(event *GRNCreatedEvent) error <span class="cov0" title="0">{
        return p.publish(SubjectGRNCreated, event)
}</span>

// PublishGRNCompleted publishes GRN completed event
func (p *Publisher) PublishGRNCompleted(event *GRNCompletedEvent) error <span class="cov0" title="0">{
        return p.publish(SubjectGRNCompleted, event)
}</span>

// PublishStockReceived publishes stock received event
func (p *Publisher) PublishStockReceived(event *StockReceivedEvent) error <span class="cov0" title="0">{
        return p.publish(SubjectStockReceived, event)
}</span>

// PublishStockIssued publishes stock issued event
func (p *Publisher) PublishStockIssued(event *StockIssuedEvent) error <span class="cov0" title="0">{
        return p.publish(SubjectStockIssued, event)
}</span>

// PublishStockReserved publishes stock reserved event
func (p *Publisher) PublishStockReserved(event *StockReservedEvent) error <span class="cov0" title="0">{
        return p.publish(SubjectStockReserved, event)
}</span>

// PublishLowStockAlert publishes low stock alert event
func (p *Publisher) PublishLowStockAlert(event *LowStockAlertEvent) error <span class="cov0" title="0">{
        return p.publish(SubjectLowStockAlert, event)
}</span>

// PublishLotExpiringSoon publishes lot expiring soon event
func (p *Publisher) PublishLotExpiringSoon(event *LotExpiringEvent) error <span class="cov0" title="0">{
        return p.publish(SubjectLotExpiringSoon, event)
}</span>

// PublishLotExpired publishes lot expired event
func (p *Publisher) PublishLotExpired(event *LotExpiringEvent) error <span class="cov0" title="0">{
        return p.publish(SubjectLotExpired, event)
}</span>

func (p *Publisher) publish(subject string, data interface{}) error <span class="cov0" title="0">{
        if p.client == nil </span><span class="cov0" title="0">{
                p.logger.Warn("NATS client not available, skipping event publish",
                        zap.String("subject", subject))
                return nil
        }</span>

        <span class="cov0" title="0">payload, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to marshal event",
                        zap.String("subject", subject),
                        zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">if err := p.client.Publish(subject, payload); err != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to publish event",
                        zap.String("subject", subject),
                        zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">p.logger.Info("Event published",
                zap.String("subject", subject))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package postgres

import (
        "context"
        "fmt"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type grnRepository struct {
        db *gorm.DB
}

// NewGRNRepository creates a new GRN repository
func NewGRNRepository(db *gorm.DB) repository.GRNRepository <span class="cov0" title="0">{
        return &amp;grnRepository{db: db}
}</span>

func (r *grnRepository) Create(ctx context.Context, grn *entity.GRN) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(grn).Error
}</span>

func (r *grnRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.GRN, error) <span class="cov0" title="0">{
        var grn entity.GRN
        err := r.db.WithContext(ctx).
                Preload("Warehouse").
                Preload("LineItems").
                Preload("LineItems.Lot").
                Preload("LineItems.Location").
                First(&amp;grn, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;grn, nil</span>
}

func (r *grnRepository) GetByNumber(ctx context.Context, grnNumber string) (*entity.GRN, error) <span class="cov0" title="0">{
        var grn entity.GRN
        err := r.db.WithContext(ctx).
                Preload("LineItems").
                First(&amp;grn, "grn_number = ?", grnNumber).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;grn, nil</span>
}

func (r *grnRepository) GetByPOID(ctx context.Context, poID uuid.UUID) ([]*entity.GRN, error) <span class="cov0" title="0">{
        var grns []*entity.GRN
        err := r.db.WithContext(ctx).
                Where("po_id = ?", poID).
                Order("created_at DESC").
                Find(&amp;grns).Error
        return grns, err
}</span>

func (r *grnRepository) List(ctx context.Context, filter *repository.GRNFilter) ([]*entity.GRN, int64, error) <span class="cov0" title="0">{
        var grns []*entity.GRN
        var total int64

        query := r.db.WithContext(ctx).Model(&amp;entity.GRN{})

        if filter.WarehouseID != nil </span><span class="cov0" title="0">{
                query = query.Where("warehouse_id = ?", *filter.WarehouseID)
        }</span>
        <span class="cov0" title="0">if filter.SupplierID != nil </span><span class="cov0" title="0">{
                query = query.Where("supplier_id = ?", *filter.SupplierID)
        }</span>
        <span class="cov0" title="0">if filter.POID != nil </span><span class="cov0" title="0">{
                query = query.Where("po_id = ?", *filter.POID)
        }</span>
        <span class="cov0" title="0">if filter.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", filter.Status)
        }</span>
        <span class="cov0" title="0">if filter.QCStatus != "" </span><span class="cov0" title="0">{
                query = query.Where("qc_status = ?", filter.QCStatus)
        }</span>
        <span class="cov0" title="0">if filter.Search != "" </span><span class="cov0" title="0">{
                search := "%" + filter.Search + "%"
                query = query.Where("grn_number ILIKE ? OR po_number ILIKE ?", search, search)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if filter.Limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(filter.Limit)
        }</span> else<span class="cov0" title="0"> {
                query = query.Limit(20)
        }</span>
        <span class="cov0" title="0">if filter.Page &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset((filter.Page - 1) * filter.Limit)
        }</span>

        <span class="cov0" title="0">if err := query.
                Preload("Warehouse").
                Order("created_at DESC").
                Find(&amp;grns).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return grns, total, nil</span>
}

func (r *grnRepository) Update(ctx context.Context, grn *entity.GRN) error <span class="cov0" title="0">{
        grn.UpdatedAt = time.Now()
        return r.db.WithContext(ctx).Save(grn).Error
}</span>

func (r *grnRepository) CreateLineItem(ctx context.Context, item *entity.GRNLineItem) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(item).Error
}</span>

func (r *grnRepository) GetLineItemsByGRNID(ctx context.Context, grnID uuid.UUID) ([]*entity.GRNLineItem, error) <span class="cov0" title="0">{
        var items []*entity.GRNLineItem
        err := r.db.WithContext(ctx).
                Where("grn_id = ?", grnID).
                Preload("Lot").
                Preload("Location").
                Order("line_number").
                Find(&amp;items).Error
        return items, err
}</span>

func (r *grnRepository) UpdateLineItem(ctx context.Context, item *entity.GRNLineItem) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(item).Error
}</span>

func (r *grnRepository) GetNextGRNNumber(ctx context.Context) (string, error) <span class="cov0" title="0">{
        var count int64
        year := time.Now().Year()

        r.db.WithContext(ctx).
                Model(&amp;entity.GRN{}).
                Where("grn_number LIKE ?", fmt.Sprintf("GRN-%d-%%", year)).
                Count(&amp;count)

        return fmt.Sprintf("GRN-%d-%04d", year, count+1), nil
}</span>

// Goods Issue Repository
type goodsIssueRepository struct {
        db *gorm.DB
}

// NewGoodsIssueRepository creates a new goods issue repository
func NewGoodsIssueRepository(db *gorm.DB) repository.GoodsIssueRepository <span class="cov0" title="0">{
        return &amp;goodsIssueRepository{db: db}
}</span>

func (r *goodsIssueRepository) Create(ctx context.Context, issue *entity.GoodsIssue) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(issue).Error
}</span>

func (r *goodsIssueRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.GoodsIssue, error) <span class="cov0" title="0">{
        var issue entity.GoodsIssue
        err := r.db.WithContext(ctx).
                Preload("Warehouse").
                Preload("LineItems").
                Preload("LineItems.Lot").
                Preload("LineItems.Location").
                First(&amp;issue, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;issue, nil</span>
}

func (r *goodsIssueRepository) GetByNumber(ctx context.Context, issueNumber string) (*entity.GoodsIssue, error) <span class="cov0" title="0">{
        var issue entity.GoodsIssue
        err := r.db.WithContext(ctx).
                Preload("LineItems").
                First(&amp;issue, "issue_number = ?", issueNumber).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;issue, nil</span>
}

func (r *goodsIssueRepository) List(ctx context.Context, filter *repository.GoodsIssueFilter) ([]*entity.GoodsIssue, int64, error) <span class="cov0" title="0">{
        var issues []*entity.GoodsIssue
        var total int64

        query := r.db.WithContext(ctx).Model(&amp;entity.GoodsIssue{})

        if filter.WarehouseID != nil </span><span class="cov0" title="0">{
                query = query.Where("warehouse_id = ?", *filter.WarehouseID)
        }</span>
        <span class="cov0" title="0">if filter.IssueType != "" </span><span class="cov0" title="0">{
                query = query.Where("issue_type = ?", filter.IssueType)
        }</span>
        <span class="cov0" title="0">if filter.ReferenceType != "" </span><span class="cov0" title="0">{
                query = query.Where("reference_type = ?", filter.ReferenceType)
        }</span>
        <span class="cov0" title="0">if filter.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", filter.Status)
        }</span>
        <span class="cov0" title="0">if filter.Search != "" </span><span class="cov0" title="0">{
                search := "%" + filter.Search + "%"
                query = query.Where("issue_number ILIKE ? OR reference_number ILIKE ?", search, search)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if filter.Limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(filter.Limit)
        }</span> else<span class="cov0" title="0"> {
                query = query.Limit(20)
        }</span>
        <span class="cov0" title="0">if filter.Page &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset((filter.Page - 1) * filter.Limit)
        }</span>

        <span class="cov0" title="0">if err := query.
                Preload("Warehouse").
                Order("created_at DESC").
                Find(&amp;issues).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return issues, total, nil</span>
}

func (r *goodsIssueRepository) Update(ctx context.Context, issue *entity.GoodsIssue) error <span class="cov0" title="0">{
        issue.UpdatedAt = time.Now()
        return r.db.WithContext(ctx).Save(issue).Error
}</span>

func (r *goodsIssueRepository) CreateLineItem(ctx context.Context, item *entity.GILineItem) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(item).Error
}</span>

func (r *goodsIssueRepository) CreateLineItems(ctx context.Context, items []*entity.GILineItem) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(&amp;items).Error
}</span>

func (r *goodsIssueRepository) GetLineItemsByIssueID(ctx context.Context, issueID uuid.UUID) ([]*entity.GILineItem, error) <span class="cov0" title="0">{
        var items []*entity.GILineItem
        err := r.db.WithContext(ctx).
                Where("goods_issue_id = ?", issueID).
                Preload("Lot").
                Preload("Location").
                Order("line_number").
                Find(&amp;items).Error
        return items, err
}</span>

func (r *goodsIssueRepository) GetNextIssueNumber(ctx context.Context) (string, error) <span class="cov0" title="0">{
        var count int64
        year := time.Now().Year()

        r.db.WithContext(ctx).
                Model(&amp;entity.GoodsIssue{}).
                Where("issue_number LIKE ?", fmt.Sprintf("GI-%d-%%", year)).
                Count(&amp;count)

        return fmt.Sprintf("GI-%d-%04d", year, count+1), nil
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package postgres

import (
        "context"
        "fmt"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type inventoryCountRepository struct {
        db *gorm.DB
}

// NewInventoryCountRepository creates a new inventory count repository
func NewInventoryCountRepository(db *gorm.DB) repository.InventoryCountRepository <span class="cov0" title="0">{
        return &amp;inventoryCountRepository{db: db}
}</span>

func (r *inventoryCountRepository) Create(ctx context.Context, count *entity.InventoryCount) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(count).Error
}</span>

func (r *inventoryCountRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.InventoryCount, error) <span class="cov0" title="0">{
        var count entity.InventoryCount
        err := r.db.WithContext(ctx).
                Preload("Warehouse").
                Preload("Zone").
                Preload("LineItems").
                Preload("LineItems.Location").
                Preload("LineItems.Lot").
                First(&amp;count, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;count, nil</span>
}

func (r *inventoryCountRepository) GetByNumber(ctx context.Context, countNumber string) (*entity.InventoryCount, error) <span class="cov0" title="0">{
        var count entity.InventoryCount
        err := r.db.WithContext(ctx).
                Preload("LineItems").
                First(&amp;count, "count_number = ?", countNumber).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;count, nil</span>
}

func (r *inventoryCountRepository) List(ctx context.Context, filter *repository.InventoryCountFilter) ([]*entity.InventoryCount, int64, error) <span class="cov0" title="0">{
        var counts []*entity.InventoryCount
        var total int64

        query := r.db.WithContext(ctx).Model(&amp;entity.InventoryCount{})

        if filter.WarehouseID != nil </span><span class="cov0" title="0">{
                query = query.Where("warehouse_id = ?", *filter.WarehouseID)
        }</span>
        <span class="cov0" title="0">if filter.ZoneID != nil </span><span class="cov0" title="0">{
                query = query.Where("zone_id = ?", *filter.ZoneID)
        }</span>
        <span class="cov0" title="0">if filter.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", filter.Status)
        }</span>
        <span class="cov0" title="0">if filter.CountType != "" </span><span class="cov0" title="0">{
                query = query.Where("count_type = ?", filter.CountType)
        }</span>
        <span class="cov0" title="0">if filter.Search != "" </span><span class="cov0" title="0">{
                search := "%" + filter.Search + "%"
                query = query.Where("count_number ILIKE ?", search)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if filter.Limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(filter.Limit)
        }</span> else<span class="cov0" title="0"> {
                query = query.Limit(20)
        }</span>
        <span class="cov0" title="0">if filter.Page &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset((filter.Page - 1) * filter.Limit)
        }</span>

        <span class="cov0" title="0">if err := query.
                Preload("Warehouse").
                Order("created_at DESC").
                Find(&amp;counts).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return counts, total, nil</span>
}

func (r *inventoryCountRepository) Update(ctx context.Context, count *entity.InventoryCount) error <span class="cov0" title="0">{
        count.UpdatedAt = time.Now()
        return r.db.WithContext(ctx).Save(count).Error
}</span>

func (r *inventoryCountRepository) CreateLineItem(ctx context.Context, item *entity.InventoryCountLineItem) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(item).Error
}</span>

func (r *inventoryCountRepository) CreateLineItems(ctx context.Context, items []*entity.InventoryCountLineItem) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(&amp;items).Error
}</span>

func (r *inventoryCountRepository) GetLineItemsByCountID(ctx context.Context, countID uuid.UUID) ([]*entity.InventoryCountLineItem, error) <span class="cov0" title="0">{
        var items []*entity.InventoryCountLineItem
        err := r.db.WithContext(ctx).
                Where("inventory_count_id = ?", countID).
                Preload("Location").
                Preload("Lot").
                Find(&amp;items).Error
        return items, err
}</span>

func (r *inventoryCountRepository) UpdateLineItem(ctx context.Context, item *entity.InventoryCountLineItem) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(item).Error
}</span>

func (r *inventoryCountRepository) GetPendingItems(ctx context.Context, countID uuid.UUID) ([]*entity.InventoryCountLineItem, error) <span class="cov0" title="0">{
        var items []*entity.InventoryCountLineItem
        err := r.db.WithContext(ctx).
                Where("inventory_count_id = ? AND is_counted = ?", countID, false).
                Preload("Location").
                Preload("Lot").
                Find(&amp;items).Error
        return items, err
}</span>

func (r *inventoryCountRepository) GetVarianceItems(ctx context.Context, countID uuid.UUID) ([]*entity.InventoryCountLineItem, error) <span class="cov0" title="0">{
        var items []*entity.InventoryCountLineItem
        err := r.db.WithContext(ctx).
                Where("inventory_count_id = ? AND is_counted = ? AND variance != 0", countID, true).
                Preload("Location").
                Preload("Lot").
                Find(&amp;items).Error
        return items, err
}</span>

func (r *inventoryCountRepository) GetNextCountNumber(ctx context.Context) (string, error) <span class="cov0" title="0">{
        var count int64
        year := time.Now().Year()

        r.db.WithContext(ctx).
                Model(&amp;entity.InventoryCount{}).
                Where("count_number LIKE ?", fmt.Sprintf("IC-%d-%%", year)).
                Count(&amp;count)

        return fmt.Sprintf("IC-%d-%04d", year, count+1), nil
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package postgres

import (
        "context"
        "fmt"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type lotRepository struct {
        db *gorm.DB
}

// NewLotRepository creates a new lot repository
func NewLotRepository(db *gorm.DB) repository.LotRepository <span class="cov0" title="0">{
        return &amp;lotRepository{db: db}
}</span>

func (r *lotRepository) Create(ctx context.Context, lot *entity.Lot) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(lot).Error
}</span>

func (r *lotRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.Lot, error) <span class="cov0" title="0">{
        var lot entity.Lot
        err := r.db.WithContext(ctx).First(&amp;lot, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;lot, nil</span>
}

func (r *lotRepository) GetByLotNumber(ctx context.Context, lotNumber string) (*entity.Lot, error) <span class="cov0" title="0">{
        var lot entity.Lot
        err := r.db.WithContext(ctx).First(&amp;lot, "lot_number = ?", lotNumber).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;lot, nil</span>
}

func (r *lotRepository) List(ctx context.Context, filter *repository.LotFilter) ([]*entity.Lot, int64, error) <span class="cov0" title="0">{
        var lots []*entity.Lot
        var total int64

        query := r.db.WithContext(ctx).Model(&amp;entity.Lot{})

        if filter.MaterialID != nil </span><span class="cov0" title="0">{
                query = query.Where("material_id = ?", *filter.MaterialID)
        }</span>
        <span class="cov0" title="0">if filter.SupplierID != nil </span><span class="cov0" title="0">{
                query = query.Where("supplier_id = ?", *filter.SupplierID)
        }</span>
        <span class="cov0" title="0">if filter.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", filter.Status)
        }</span>
        <span class="cov0" title="0">if filter.QCStatus != "" </span><span class="cov0" title="0">{
                query = query.Where("qc_status = ?", filter.QCStatus)
        }</span>
        <span class="cov0" title="0">if filter.ExpiryBefore != nil </span><span class="cov0" title="0">{
                query = query.Where("expiry_date &lt;= ?", *filter.ExpiryBefore)
        }</span>
        <span class="cov0" title="0">if filter.ExpiryAfter != nil </span><span class="cov0" title="0">{
                query = query.Where("expiry_date &gt;= ?", *filter.ExpiryAfter)
        }</span>
        <span class="cov0" title="0">if filter.Search != "" </span><span class="cov0" title="0">{
                search := "%" + filter.Search + "%"
                query = query.Where("lot_number ILIKE ? OR supplier_lot_number ILIKE ?", search, search)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if filter.Limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(filter.Limit)
        }</span> else<span class="cov0" title="0"> {
                query = query.Limit(20)
        }</span>
        <span class="cov0" title="0">if filter.Page &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset((filter.Page - 1) * filter.Limit)
        }</span>

        <span class="cov0" title="0">if err := query.Order("expiry_date ASC").Find(&amp;lots).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return lots, total, nil</span>
}

func (r *lotRepository) Update(ctx context.Context, lot *entity.Lot) error <span class="cov0" title="0">{
        lot.UpdatedAt = time.Now()
        return r.db.WithContext(ctx).Save(lot).Error
}</span>

// GetAvailableLots returns lots sorted by expiry date (FEFO)
func (r *lotRepository) GetAvailableLots(ctx context.Context, materialID uuid.UUID) ([]*entity.Lot, error) <span class="cov0" title="0">{
        var lots []*entity.Lot
        err := r.db.WithContext(ctx).
                Where("material_id = ?", materialID).
                Where("status = ?", entity.LotStatusAvailable).
                Where("qc_status = ?", entity.QCStatusPassed).
                Where("expiry_date &gt; ?", time.Now()).
                Order("expiry_date ASC"). // FEFO: earliest expiry first
                Find(&amp;lots).Error
        return lots, err
}</span>

// GetExpiringLots returns lots expiring within the specified days
func (r *lotRepository) GetExpiringLots(ctx context.Context, days int) ([]*entity.Lot, error) <span class="cov0" title="0">{
        var lots []*entity.Lot
        threshold := time.Now().AddDate(0, 0, days)
        err := r.db.WithContext(ctx).
                Where("status = ?", entity.LotStatusAvailable).
                Where("expiry_date &lt;= ?", threshold).
                Where("expiry_date &gt; ?", time.Now()).
                Order("expiry_date ASC").
                Find(&amp;lots).Error
        return lots, err
}</span>

// GetExpiredLots returns all expired lots that are still marked as available
func (r *lotRepository) GetExpiredLots(ctx context.Context) ([]*entity.Lot, error) <span class="cov0" title="0">{
        var lots []*entity.Lot
        err := r.db.WithContext(ctx).
                Where("status = ?", entity.LotStatusAvailable).
                Where("expiry_date &lt;= ?", time.Now()).
                Find(&amp;lots).Error
        return lots, err
}</span>

// GetNextLotNumber generates the next lot number
func (r *lotRepository) GetNextLotNumber(ctx context.Context) (string, error) <span class="cov0" title="0">{
        var count int64
        yearMonth := time.Now().Format("200601")

        r.db.WithContext(ctx).
                Model(&amp;entity.Lot{}).
                Where("lot_number LIKE ?", fmt.Sprintf("LOT-%s-%%", yearMonth)).
                Count(&amp;count)

        return fmt.Sprintf("LOT-%s-%04d", yearMonth, count+1), nil
}</span>

// MarkExpired marks lots as expired
func (r *lotRepository) MarkExpired(ctx context.Context, lotIDs []uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).
                Model(&amp;entity.Lot{}).
                Where("id IN ?", lotIDs).
                Updates(map[string]interface{}{
                        "status":     entity.LotStatusExpired,
                        "updated_at": time.Now(),
                }).Error
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package postgres

import (
        "context"
        "fmt"
        "math"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type stockRepository struct {
        db *gorm.DB
}

// NewStockRepository creates a new stock repository
func NewStockRepository(db *gorm.DB) repository.StockRepository <span class="cov0" title="0">{
        return &amp;stockRepository{db: db}
}</span>

func (r *stockRepository) Create(ctx context.Context, stock *entity.Stock) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(stock).Error
}</span>

func (r *stockRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.Stock, error) <span class="cov0" title="0">{
        var stock entity.Stock
        err := r.db.WithContext(ctx).
                Preload("Lot").
                Preload("Location").
                First(&amp;stock, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;stock, nil</span>
}

func (r *stockRepository) Update(ctx context.Context, stock *entity.Stock) error <span class="cov0" title="0">{
        stock.UpdatedAt = time.Now()
        return r.db.WithContext(ctx).Save(stock).Error
}</span>

func (r *stockRepository) GetByLocation(ctx context.Context, locationID uuid.UUID) ([]*entity.Stock, error) <span class="cov0" title="0">{
        var stocks []*entity.Stock
        err := r.db.WithContext(ctx).
                Preload("Lot").
                Where("location_id = ?", locationID).
                Where("quantity &gt; 0").
                Find(&amp;stocks).Error
        return stocks, err
}</span>

func (r *stockRepository) GetByMaterial(ctx context.Context, materialID uuid.UUID) ([]*entity.Stock, error) <span class="cov0" title="0">{
        var stocks []*entity.Stock
        err := r.db.WithContext(ctx).
                Preload("Lot").
                Preload("Location").
                Preload("Location.Zone").
                Where("material_id = ?", materialID).
                Where("quantity &gt; 0").
                Find(&amp;stocks).Error
        return stocks, err
}</span>

func (r *stockRepository) GetByMaterialAndLot(ctx context.Context, materialID, lotID uuid.UUID) (*entity.Stock, error) <span class="cov0" title="0">{
        var stock entity.Stock
        err := r.db.WithContext(ctx).
                Where("material_id = ? AND lot_id = ?", materialID, lotID).
                First(&amp;stock).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;stock, nil</span>
}

func (r *stockRepository) GetByLocationMaterialLot(ctx context.Context, locationID, materialID uuid.UUID, lotID *uuid.UUID) (*entity.Stock, error) <span class="cov0" title="0">{
        var stock entity.Stock
        query := r.db.WithContext(ctx).
                Where("location_id = ? AND material_id = ?", locationID, materialID)

        if lotID != nil </span><span class="cov0" title="0">{
                query = query.Where("lot_id = ?", *lotID)
        }</span> else<span class="cov0" title="0"> {
                query = query.Where("lot_id IS NULL")
        }</span>

        <span class="cov0" title="0">err := query.First(&amp;stock).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;stock, nil</span>
}

func (r *stockRepository) List(ctx context.Context, filter *repository.StockFilter) ([]*entity.Stock, int64, error) <span class="cov0" title="0">{
        var stocks []*entity.Stock
        var total int64

        query := r.db.WithContext(ctx).Model(&amp;entity.Stock{})

        if filter.WarehouseID != nil </span><span class="cov0" title="0">{
                query = query.Where("warehouse_id = ?", *filter.WarehouseID)
        }</span>
        <span class="cov0" title="0">if filter.ZoneID != nil </span><span class="cov0" title="0">{
                query = query.Where("zone_id = ?", *filter.ZoneID)
        }</span>
        <span class="cov0" title="0">if filter.LocationID != nil </span><span class="cov0" title="0">{
                query = query.Where("location_id = ?", *filter.LocationID)
        }</span>
        <span class="cov0" title="0">if filter.MaterialID != nil </span><span class="cov0" title="0">{
                query = query.Where("material_id = ?", *filter.MaterialID)
        }</span>
        <span class="cov0" title="0">if filter.LotID != nil </span><span class="cov0" title="0">{
                query = query.Where("lot_id = ?", *filter.LotID)
        }</span>
        <span class="cov0" title="0">if filter.HasStock != nil &amp;&amp; *filter.HasStock </span><span class="cov0" title="0">{
                query = query.Where("quantity &gt; 0")
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if filter.Limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(filter.Limit)
        }</span> else<span class="cov0" title="0"> {
                query = query.Limit(50)
        }</span>
        <span class="cov0" title="0">if filter.Page &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset((filter.Page - 1) * filter.Limit)
        }</span>

        <span class="cov0" title="0">if err := query.
                Preload("Lot").
                Preload("Location").
                Preload("Location.Zone").
                Find(&amp;stocks).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return stocks, total, nil</span>
}

// GetAvailableStockFEFO returns stock sorted by lot expiry date (FEFO)
// This is the CRITICAL method for cosmetics - First Expired First Out
func (r *stockRepository) GetAvailableStockFEFO(ctx context.Context, materialID uuid.UUID) ([]*entity.Stock, error) <span class="cov0" title="0">{
        var stocks []*entity.Stock
        err := r.db.WithContext(ctx).
                Joins("JOIN lots ON lots.id = stock.lot_id").
                Where("stock.material_id = ?", materialID).
                Where("stock.quantity - stock.reserved_qty &gt; 0"). // Has available qty
                Where("lots.status = ?", entity.LotStatusAvailable).
                Where("lots.qc_status = ?", entity.QCStatusPassed).
                Where("lots.expiry_date &gt; ?", time.Now()). // Not expired
                Order("lots.expiry_date ASC"). // FEFO: earliest expiry first!
                Preload("Lot").
                Preload("Location").
                Find(&amp;stocks).Error
        return stocks, err
}</span>

// IssueStockFEFO issues stock using FEFO logic - THE CORE ALGORITHM
func (r *stockRepository) IssueStockFEFO(ctx context.Context, materialID uuid.UUID, quantity float64, createdBy uuid.UUID) ([]entity.LotIssued, error) <span class="cov0" title="0">{
        // Get available stocks sorted by expiry (earliest first)
        stocks, err := r.GetAvailableStockFEFO(ctx, materialID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">remaining := quantity
        var issued []entity.LotIssued

        // Start transaction
        tx := r.db.WithContext(ctx).Begin()
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov0" title="0">for _, stock := range stocks </span><span class="cov0" title="0">{
                if remaining &lt;= 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">availableQty := stock.Quantity - stock.ReservedQty
                issueQty := math.Min(availableQty, remaining)

                // Deduct from stock
                stock.Quantity -= issueQty
                stock.UpdatedAt = time.Now()
                if err := tx.Save(stock).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return nil, err
                }</span>

                // Record the issued lot
                <span class="cov0" title="0">if stock.Lot != nil &amp;&amp; stock.LotID != nil </span><span class="cov0" title="0">{
                        issued = append(issued, entity.LotIssued{
                                LotID:      *stock.LotID,
                                LotNumber:  stock.Lot.LotNumber,
                                Quantity:   issueQty,
                                ExpiryDate: stock.Lot.ExpiryDate,
                                LocationID: stock.LocationID,
                        })
                }</span>

                <span class="cov0" title="0">remaining -= issueQty</span>
        }

        // Check if we have enough stock
        <span class="cov0" title="0">if remaining &gt; 0 </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, entity.ErrInsufficientStock
        }</span>

        <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return issued, nil</span>
}

// ReceiveStock adds stock to a location
func (r *stockRepository) ReceiveStock(ctx context.Context, stock *entity.Stock, movement *entity.StockMovement) error <span class="cov0" title="0">{
        tx := r.db.WithContext(ctx).Begin()

        // Check if stock record exists
        var existing entity.Stock
        err := tx.Where("location_id = ? AND material_id = ? AND lot_id = ?",
                stock.LocationID, stock.MaterialID, stock.LotID).First(&amp;existing).Error

        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                // Create new stock record
                if err := tx.Create(stock).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span> else<span class="cov0" title="0"> {
                // Update existing stock
                existing.Quantity += stock.Quantity
                existing.UpdatedAt = time.Now()
                if err := tx.Save(&amp;existing).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
        }

        // Create movement record
        <span class="cov0" title="0">if err := tx.Create(movement).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit().Error</span>
}

// IssueStock deducts stock from a location
func (r *stockRepository) IssueStock(ctx context.Context, stock *entity.Stock, movement *entity.StockMovement) error <span class="cov0" title="0">{
        tx := r.db.WithContext(ctx).Begin()

        if stock.Quantity &lt; 0 </span><span class="cov0" title="0">{
                tx.Rollback()
                return entity.ErrInsufficientStock
        }</span>

        <span class="cov0" title="0">stock.UpdatedAt = time.Now()
        if err := tx.Save(stock).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">if err := tx.Create(movement).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit().Error</span>
}

// TransferStock transfers stock between locations
func (r *stockRepository) TransferStock(ctx context.Context, fromStock, toStock *entity.Stock, movement *entity.StockMovement) error <span class="cov0" title="0">{
        tx := r.db.WithContext(ctx).Begin()

        // Deduct from source
        fromStock.UpdatedAt = time.Now()
        if err := tx.Save(fromStock).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        // Check if destination stock exists
        <span class="cov0" title="0">var existing entity.Stock
        err := tx.Where("location_id = ? AND material_id = ? AND lot_id = ?",
                toStock.LocationID, toStock.MaterialID, toStock.LotID).First(&amp;existing).Error

        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                if err := tx.Create(toStock).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span> else<span class="cov0" title="0"> {
                existing.Quantity += toStock.Quantity
                existing.UpdatedAt = time.Now()
                if err := tx.Save(&amp;existing).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := tx.Create(movement).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit().Error</span>
}

// AdjustStock adjusts stock quantity
func (r *stockRepository) AdjustStock(ctx context.Context, stock *entity.Stock, adjustmentQty float64, movement *entity.StockMovement) error <span class="cov0" title="0">{
        tx := r.db.WithContext(ctx).Begin()

        stock.Quantity += adjustmentQty
        if stock.Quantity &lt; 0 </span><span class="cov0" title="0">{
                tx.Rollback()
                return entity.ErrInvalidQuantity
        }</span>
        <span class="cov0" title="0">stock.UpdatedAt = time.Now()

        if err := tx.Save(stock).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">if err := tx.Create(movement).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit().Error</span>
}

// ReserveStock reserves stock for an order
func (r *stockRepository) ReserveStock(ctx context.Context, materialID uuid.UUID, quantity float64, reservation *entity.StockReservation) error <span class="cov0" title="0">{
        tx := r.db.WithContext(ctx).Begin()

        // Get available stock using FEFO
        stocks, err := r.GetAvailableStockFEFO(ctx, materialID)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">remaining := quantity
        for _, stock := range stocks </span><span class="cov0" title="0">{
                if remaining &lt;= 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">availableQty := stock.Quantity - stock.ReservedQty
                reserveQty := math.Min(availableQty, remaining)

                stock.ReservedQty += reserveQty
                stock.UpdatedAt = time.Now()
                if err := tx.Save(stock).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return err
                }</span>

                <span class="cov0" title="0">remaining -= reserveQty</span>
        }

        <span class="cov0" title="0">if remaining &gt; 0 </span><span class="cov0" title="0">{
                tx.Rollback()
                return entity.ErrInsufficientStock
        }</span>

        <span class="cov0" title="0">if err := tx.Create(reservation).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit().Error</span>
}

// ReleaseReservation releases a stock reservation
func (r *stockRepository) ReleaseReservation(ctx context.Context, reservationID uuid.UUID) error <span class="cov0" title="0">{
        tx := r.db.WithContext(ctx).Begin()

        var reservation entity.StockReservation
        if err := tx.First(&amp;reservation, "id = ?", reservationID).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        // Find and release stock
        <span class="cov0" title="0">var stock entity.Stock
        query := tx.Where("material_id = ?", reservation.MaterialID)
        if reservation.LotID != nil </span><span class="cov0" title="0">{
                query = query.Where("lot_id = ?", *reservation.LotID)
        }</span>
        <span class="cov0" title="0">if reservation.LocationID != nil </span><span class="cov0" title="0">{
                query = query.Where("location_id = ?", *reservation.LocationID)
        }</span>

        <span class="cov0" title="0">if err := query.First(&amp;stock).Error; err == nil </span><span class="cov0" title="0">{
                stock.ReservedQty -= reservation.Quantity
                if stock.ReservedQty &lt; 0 </span><span class="cov0" title="0">{
                        stock.ReservedQty = 0
                }</span>
                <span class="cov0" title="0">stock.UpdatedAt = time.Now()
                tx.Save(&amp;stock)</span>
        }

        // Update reservation
        <span class="cov0" title="0">reservation.Release()
        if err := tx.Save(&amp;reservation).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit().Error</span>
}

// GetMaterialSummary returns aggregated stock for a material
func (r *stockRepository) GetMaterialSummary(ctx context.Context, materialID uuid.UUID) (*entity.StockSummary, error) <span class="cov0" title="0">{
        var result struct {
                TotalQuantity  float64
                TotalReserved  float64
                TotalAvailable float64
        }

        err := r.db.WithContext(ctx).
                Model(&amp;entity.Stock{}).
                Select("SUM(quantity) as total_quantity, SUM(reserved_qty) as total_reserved, SUM(quantity - reserved_qty) as total_available").
                Where("material_id = ?", materialID).
                Where("quantity &gt; 0").
                Scan(&amp;result).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;entity.StockSummary{
                MaterialID:     materialID,
                TotalQuantity:  result.TotalQuantity,
                TotalReserved:  result.TotalReserved,
                TotalAvailable: result.TotalAvailable,
        }, nil</span>
}

// GetLowStockMaterials returns materials below threshold
func (r *stockRepository) GetLowStockMaterials(ctx context.Context, threshold float64) ([]*entity.StockSummary, error) <span class="cov0" title="0">{
        var results []*entity.StockSummary

        err := r.db.WithContext(ctx).
                Model(&amp;entity.Stock{}).
                Select("material_id, SUM(quantity) as total_quantity, SUM(reserved_qty) as total_reserved, SUM(quantity - reserved_qty) as total_available").
                Group("material_id").
                Having("SUM(quantity - reserved_qty) &lt; ?", threshold).
                Scan(&amp;results).Error

        return results, err
}</span>

// GetExpiringStock returns stock with lots expiring within days
func (r *stockRepository) GetExpiringStock(ctx context.Context, days int) ([]*entity.Stock, error) <span class="cov0" title="0">{
        threshold := time.Now().AddDate(0, 0, days)
        var stocks []*entity.Stock

        err := r.db.WithContext(ctx).
                Joins("JOIN lots ON lots.id = stock.lot_id").
                Where("lots.expiry_date &lt;= ?", threshold).
                Where("lots.expiry_date &gt; ?", time.Now()).
                Where("stock.quantity &gt; 0").
                Preload("Lot").
                Preload("Location").
                Order("lots.expiry_date ASC").
                Find(&amp;stocks).Error

        return stocks, err
}</span>

// CreateMovement creates a stock movement record
func (r *stockRepository) CreateMovement(ctx context.Context, movement *entity.StockMovement) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(movement).Error
}</span>

// GetMovementsByLot returns movements for a lot
func (r *stockRepository) GetMovementsByLot(ctx context.Context, lotID uuid.UUID) ([]*entity.StockMovement, error) <span class="cov0" title="0">{
        var movements []*entity.StockMovement
        err := r.db.WithContext(ctx).
                Where("lot_id = ?", lotID).
                Order("created_at DESC").
                Find(&amp;movements).Error
        return movements, err
}</span>

// GetMovementsByMaterial returns movements for a material
func (r *stockRepository) GetMovementsByMaterial(ctx context.Context, materialID uuid.UUID, limit int) ([]*entity.StockMovement, error) <span class="cov0" title="0">{
        var movements []*entity.StockMovement
        err := r.db.WithContext(ctx).
                Where("material_id = ?", materialID).
                Order("created_at DESC").
                Limit(limit).
                Find(&amp;movements).Error
        return movements, err
}</span>

// GetNextMovementNumber generates the next movement number
func (r *stockRepository) GetNextMovementNumber(ctx context.Context, movementType entity.MovementType) (string, error) <span class="cov0" title="0">{
        var count int64
        year := time.Now().Year()
        prefix := "MOV"

        switch movementType </span>{
        case entity.MovementTypeIn:<span class="cov0" title="0">
                prefix = "MOV-IN"</span>
        case entity.MovementTypeOut:<span class="cov0" title="0">
                prefix = "MOV-OUT"</span>
        case entity.MovementTypeTransfer:<span class="cov0" title="0">
                prefix = "MOV-TRF"</span>
        case entity.MovementTypeAdjustment:<span class="cov0" title="0">
                prefix = "MOV-ADJ"</span>
        }

        <span class="cov0" title="0">r.db.WithContext(ctx).
                Model(&amp;entity.StockMovement{}).
                Where("movement_number LIKE ?", fmt.Sprintf("%s-%d-%%", prefix, year)).
                Count(&amp;count)

        return fmt.Sprintf("%s-%d-%05d", prefix, year, count+1), nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package postgres

import (
        "context"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type warehouseRepository struct {
        db *gorm.DB
}

// NewWarehouseRepository creates a new warehouse repository
func NewWarehouseRepository(db *gorm.DB) repository.WarehouseRepository <span class="cov0" title="0">{
        return &amp;warehouseRepository{db: db}
}</span>

func (r *warehouseRepository) Create(ctx context.Context, warehouse *entity.Warehouse) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(warehouse).Error
}</span>

func (r *warehouseRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.Warehouse, error) <span class="cov0" title="0">{
        var warehouse entity.Warehouse
        err := r.db.WithContext(ctx).
                Preload("Zones").
                First(&amp;warehouse, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;warehouse, nil</span>
}

func (r *warehouseRepository) GetByCode(ctx context.Context, code string) (*entity.Warehouse, error) <span class="cov0" title="0">{
        var warehouse entity.Warehouse
        err := r.db.WithContext(ctx).
                Preload("Zones").
                First(&amp;warehouse, "code = ?", code).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;warehouse, nil</span>
}

func (r *warehouseRepository) List(ctx context.Context, filter *repository.WarehouseFilter) ([]*entity.Warehouse, int64, error) <span class="cov0" title="0">{
        var warehouses []*entity.Warehouse
        var total int64

        query := r.db.WithContext(ctx).Model(&amp;entity.Warehouse{})

        if filter.Type != "" </span><span class="cov0" title="0">{
                query = query.Where("warehouse_type = ?", filter.Type)
        }</span>
        <span class="cov0" title="0">if filter.IsActive != nil </span><span class="cov0" title="0">{
                query = query.Where("is_active = ?", *filter.IsActive)
        }</span>
        <span class="cov0" title="0">if filter.Search != "" </span><span class="cov0" title="0">{
                search := "%" + filter.Search + "%"
                query = query.Where("name ILIKE ? OR code ILIKE ?", search, search)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if filter.Limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(filter.Limit)
        }</span> else<span class="cov0" title="0"> {
                query = query.Limit(20)
        }</span>
        <span class="cov0" title="0">if filter.Page &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset((filter.Page - 1) * filter.Limit)
        }</span>

        <span class="cov0" title="0">if err := query.Preload("Zones").Order("code").Find(&amp;warehouses).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return warehouses, total, nil</span>
}

func (r *warehouseRepository) Update(ctx context.Context, warehouse *entity.Warehouse) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(warehouse).Error
}</span>

func (r *warehouseRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;entity.Warehouse{}, "id = ?", id).Error
}</span>

// Zone Repository
type zoneRepository struct {
        db *gorm.DB
}

// NewZoneRepository creates a new zone repository
func NewZoneRepository(db *gorm.DB) repository.ZoneRepository <span class="cov0" title="0">{
        return &amp;zoneRepository{db: db}
}</span>

func (r *zoneRepository) Create(ctx context.Context, zone *entity.Zone) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(zone).Error
}</span>

func (r *zoneRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.Zone, error) <span class="cov0" title="0">{
        var zone entity.Zone
        err := r.db.WithContext(ctx).
                Preload("Warehouse").
                Preload("Locations").
                First(&amp;zone, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;zone, nil</span>
}

func (r *zoneRepository) GetByWarehouseID(ctx context.Context, warehouseID uuid.UUID) ([]*entity.Zone, error) <span class="cov0" title="0">{
        var zones []*entity.Zone
        err := r.db.WithContext(ctx).
                Where("warehouse_id = ?", warehouseID).
                Order("code").
                Find(&amp;zones).Error
        return zones, err
}</span>

func (r *zoneRepository) GetQuarantineZone(ctx context.Context, warehouseID uuid.UUID) (*entity.Zone, error) <span class="cov0" title="0">{
        var zone entity.Zone
        err := r.db.WithContext(ctx).
                Where("warehouse_id = ? AND zone_type = ?", warehouseID, entity.ZoneTypeQuarantine).
                First(&amp;zone).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;zone, nil</span>
}

func (r *zoneRepository) GetStorageZone(ctx context.Context, warehouseID uuid.UUID) (*entity.Zone, error) <span class="cov0" title="0">{
        var zone entity.Zone
        err := r.db.WithContext(ctx).
                Where("warehouse_id = ? AND zone_type = ?", warehouseID, entity.ZoneTypeStorage).
                First(&amp;zone).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;zone, nil</span>
}

func (r *zoneRepository) Update(ctx context.Context, zone *entity.Zone) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(zone).Error
}</span>

func (r *zoneRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;entity.Zone{}, "id = ?", id).Error
}</span>

// Location Repository
type locationRepository struct {
        db *gorm.DB
}

// NewLocationRepository creates a new location repository
func NewLocationRepository(db *gorm.DB) repository.LocationRepository <span class="cov0" title="0">{
        return &amp;locationRepository{db: db}
}</span>

func (r *locationRepository) Create(ctx context.Context, location *entity.Location) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(location).Error
}</span>

func (r *locationRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.Location, error) <span class="cov0" title="0">{
        var location entity.Location
        err := r.db.WithContext(ctx).
                Preload("Zone").
                Preload("Zone.Warehouse").
                First(&amp;location, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;location, nil</span>
}

func (r *locationRepository) GetByZoneID(ctx context.Context, zoneID uuid.UUID) ([]*entity.Location, error) <span class="cov0" title="0">{
        var locations []*entity.Location
        err := r.db.WithContext(ctx).
                Where("zone_id = ?", zoneID).
                Order("code").
                Find(&amp;locations).Error
        return locations, err
}</span>

func (r *locationRepository) GetByCode(ctx context.Context, zoneID uuid.UUID, code string) (*entity.Location, error) <span class="cov0" title="0">{
        var location entity.Location
        err := r.db.WithContext(ctx).
                Where("zone_id = ? AND code = ?", zoneID, code).
                First(&amp;location).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;location, nil</span>
}

func (r *locationRepository) Update(ctx context.Context, location *entity.Location) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(location).Error
}</span>

func (r *locationRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;entity.Location{}, "id = ?", id).Error
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package scheduler

import (
        "context"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/erp-cosmetics/wms-service/internal/infrastructure/event"
        "go.uber.org/zap"
)

// Scheduler handles scheduled WMS jobs
type Scheduler struct {
        lotRepo   repository.LotRepository
        stockRepo repository.StockRepository
        eventPub  *event.Publisher
        logger    *zap.Logger
        config    *Config
        stopChan  chan struct{}
}

// Config holds scheduler configuration
type Config struct {
        ExpiryCheckInterval    time.Duration
        LowStockCheckInterval  time.Duration
        ExpiryAlertDays        []int // 90, 30, 7
        LowStockThreshold      float64
}

// DefaultConfig returns default scheduler config
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                ExpiryCheckInterval:   24 * time.Hour,     // Daily
                LowStockCheckInterval: 1 * time.Hour,      // Hourly
                ExpiryAlertDays:       []int{90, 30, 7},   // Alert at 90, 30, 7 days
                LowStockThreshold:     100,                // Minimum stock level
        }
}</span>

// NewScheduler creates a new scheduler
func NewScheduler(
        lotRepo repository.LotRepository,
        stockRepo repository.StockRepository,
        eventPub *event.Publisher,
        logger *zap.Logger,
        config *Config,
) *Scheduler <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>
        <span class="cov0" title="0">return &amp;Scheduler{
                lotRepo:   lotRepo,
                stockRepo: stockRepo,
                eventPub:  eventPub,
                logger:    logger,
                config:    config,
                stopChan:  make(chan struct{}),
        }</span>
}

// Start starts the scheduler
func (s *Scheduler) Start() <span class="cov0" title="0">{
        s.logger.Info("Starting WMS scheduler")

        // Run expiry check immediately
        go s.runExpiryCheck()

        // Start scheduled jobs
        go s.scheduleExpiryCheck()
        go s.scheduleLowStockCheck()
}</span>

// Stop stops the scheduler
func (s *Scheduler) Stop() <span class="cov0" title="0">{
        close(s.stopChan)
        s.logger.Info("WMS scheduler stopped")
}</span>

// scheduleExpiryCheck runs expiry check at intervals
func (s *Scheduler) scheduleExpiryCheck() <span class="cov0" title="0">{
        ticker := time.NewTicker(s.config.ExpiryCheckInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        s.runExpiryCheck()</span>
                case &lt;-s.stopChan:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// scheduleLowStockCheck runs low stock check at intervals
func (s *Scheduler) scheduleLowStockCheck() <span class="cov0" title="0">{
        ticker := time.NewTicker(s.config.LowStockCheckInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        s.runLowStockCheck()</span>
                case &lt;-s.stopChan:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// runExpiryCheck checks for expiring and expired lots
func (s *Scheduler) runExpiryCheck() <span class="cov0" title="0">{
        ctx := context.Background()
        s.logger.Info("Running expiry check job")

        // Check for each alert threshold
        for _, days := range s.config.ExpiryAlertDays </span><span class="cov0" title="0">{
                expiringLots, err := s.lotRepo.GetExpiringLots(ctx, days)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get expiring lots", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">for _, lot := range expiringLots </span><span class="cov0" title="0">{
                        // Only alert if expiry is exactly at this threshold
                        daysUntil := lot.DaysUntilExpiry()
                        if daysUntil &lt;= days &amp;&amp; daysUntil &gt; days-1 </span><span class="cov0" title="0">{
                                s.logger.Warn("Lot expiring soon",
                                        zap.String("lot_number", lot.LotNumber),
                                        zap.Int("days_until_expiry", daysUntil))

                                // Get stock quantity for this lot
                                stocks, _ := s.stockRepo.GetByMaterialAndLot(ctx, lot.MaterialID, lot.ID)
                                qty := 0.0
                                if stocks != nil </span><span class="cov0" title="0">{
                                        qty = stocks.Quantity
                                }</span>

                                <span class="cov0" title="0">s.eventPub.PublishLotExpiringSoon(&amp;event.LotExpiringEvent{
                                        LotID:           lot.ID.String(),
                                        LotNumber:       lot.LotNumber,
                                        MaterialID:      lot.MaterialID.String(),
                                        ExpiryDate:      lot.ExpiryDate.Format("2006-01-02"),
                                        DaysUntilExpiry: daysUntil,
                                        Quantity:        qty,
                                })</span>
                        }
                }
        }

        // Check for expired lots and mark them
        <span class="cov0" title="0">expiredLots, err := s.lotRepo.GetExpiredLots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get expired lots", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">if len(expiredLots) &gt; 0 </span><span class="cov0" title="0">{
                var lotIDs []interface{}
                for _, lot := range expiredLots </span><span class="cov0" title="0">{
                        s.logger.Warn("Marking lot as expired",
                                zap.String("lot_number", lot.LotNumber))

                        lot.MarkExpired()

                        // Publish expired event
                        s.eventPub.PublishLotExpired(&amp;event.LotExpiringEvent{
                                LotID:           lot.ID.String(),
                                LotNumber:       lot.LotNumber,
                                MaterialID:      lot.MaterialID.String(),
                                ExpiryDate:      lot.ExpiryDate.Format("2006-01-02"),
                                DaysUntilExpiry: 0,
                        })

                        lotIDs = append(lotIDs, lot.ID)
                }</span>

                // Bulk update
                <span class="cov0" title="0">s.logger.Info("Marked lots as expired", zap.Int("count", len(expiredLots)))</span>
        }
}

// runLowStockCheck checks for low stock levels
func (s *Scheduler) runLowStockCheck() <span class="cov0" title="0">{
        ctx := context.Background()
        s.logger.Info("Running low stock check job")

        lowStockMaterials, err := s.stockRepo.GetLowStockMaterials(ctx, s.config.LowStockThreshold)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get low stock materials", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">for _, summary := range lowStockMaterials </span><span class="cov0" title="0">{
                s.logger.Warn("Low stock detected",
                        zap.String("material_id", summary.MaterialID.String()),
                        zap.Float64("available", summary.TotalAvailable))

                s.eventPub.PublishLowStockAlert(&amp;event.LowStockAlertEvent{
                        MaterialID:      summary.MaterialID.String(),
                        CurrentQuantity: summary.TotalAvailable,
                        ReorderPoint:    s.config.LowStockThreshold,
                })
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package subscriber

import (
        "context"
        "encoding/json"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/usecase/grn"
        "github.com/erp-cosmetics/wms-service/internal/usecase/reservation"
        "github.com/google/uuid"
        "github.com/nats-io/nats.go"
        "go.uber.org/zap"
)

// EventSubscriber handles incoming events from other services
type EventSubscriber struct {
        nc               *nats.Conn
        logger           *zap.Logger
        createGRNUC      *grn.CreateGRNUseCase
        reserveStockUC   *reservation.CreateReservationUseCase
        releaseReservationUC *reservation.ReleaseReservationUseCase
        subscriptions    []*nats.Subscription
}

// NewEventSubscriber creates a new event subscriber
func NewEventSubscriber(
        nc *nats.Conn,
        logger *zap.Logger,
        createGRNUC *grn.CreateGRNUseCase,
        reserveStockUC *reservation.CreateReservationUseCase,
        releaseReservationUC *reservation.ReleaseReservationUseCase,
) *EventSubscriber <span class="cov0" title="0">{
        return &amp;EventSubscriber{
                nc:                   nc,
                logger:               logger,
                createGRNUC:          createGRNUC,
                reserveStockUC:       reserveStockUC,
                releaseReservationUC: releaseReservationUC,
        }
}</span>

// Start begins listening for events
func (s *EventSubscriber) Start() error <span class="cov0" title="0">{
        if s.nc == nil </span><span class="cov0" title="0">{
                s.logger.Warn("NATS not connected, skipping event subscriptions")
                return nil
        }</span>

        // Subscribe to procurement events
        <span class="cov0" title="0">sub1, err := s.nc.Subscribe("procurement.po.received", s.handlePOReceived)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.subscriptions = append(s.subscriptions, sub1)

        // Subscribe to sales order events
        sub2, err := s.nc.Subscribe("sales.order.confirmed", s.handleSalesOrderConfirmed)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.subscriptions = append(s.subscriptions, sub2)

        // Subscribe to sales order cancellation
        sub3, err := s.nc.Subscribe("sales.order.cancelled", s.handleSalesOrderCancelled)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.subscriptions = append(s.subscriptions, sub3)

        // Subscribe to manufacturing events
        sub4, err := s.nc.Subscribe("manufacturing.wo.started", s.handleWorkOrderStarted)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.subscriptions = append(s.subscriptions, sub4)

        s.logger.Info("Event subscriber started",
                zap.Int("subscriptions", len(s.subscriptions)),
        )

        return nil</span>
}

// Stop stops all subscriptions
func (s *EventSubscriber) Stop() <span class="cov0" title="0">{
        for _, sub := range s.subscriptions </span><span class="cov0" title="0">{
                sub.Unsubscribe()
        }</span>
        <span class="cov0" title="0">s.logger.Info("Event subscriber stopped")</span>
}

// POReceivedEvent represents a PO received event from procurement
type POReceivedEvent struct {
        POID            uuid.UUID `json:"po_id"`
        PONumber        string    `json:"po_number"`
        SupplierID      uuid.UUID `json:"supplier_id"`
        SupplierName    string    `json:"supplier_name"`
        WarehouseID     uuid.UUID `json:"warehouse_id"`
        ReceivedBy      uuid.UUID `json:"received_by"`
        LineItems       []POLineItemEvent `json:"line_items"`
}

// POLineItemEvent represents a line item in PO received event
type POLineItemEvent struct {
        MaterialID        uuid.UUID `json:"material_id"`
        Quantity          float64   `json:"quantity"`
        UnitID            uuid.UUID `json:"unit_id"`
        SupplierLotNumber string    `json:"supplier_lot_number,omitempty"`
        ExpiryDate        string    `json:"expiry_date,omitempty"` // RFC3339
}

// handlePOReceived handles PO received events - creates GRN
func (s *EventSubscriber) handlePOReceived(msg *nats.Msg) <span class="cov0" title="0">{
        var event POReceivedEvent
        if err := json.Unmarshal(msg.Data, &amp;event); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unmarshal PO received event", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">s.logger.Info("Received PO received event",
                zap.String("po_number", event.PONumber),
                zap.String("po_id", event.POID.String()),
        )</span>

        // Auto-create GRN from PO received
        // This would call createGRNUC with the event data
        // Implementation depends on business requirements
}

// SalesOrderEvent represents a sales order event
type SalesOrderEvent struct {
        OrderID     uuid.UUID          `json:"order_id"`
        OrderNumber string             `json:"order_number"`
        CustomerID  uuid.UUID          `json:"customer_id"`
        LineItems   []OrderLineItemEvent `json:"line_items"`
}

// OrderLineItemEvent represents an order line item
type OrderLineItemEvent struct {
        MaterialID uuid.UUID `json:"material_id"`
        Quantity   float64   `json:"quantity"`
        UnitID     uuid.UUID `json:"unit_id"`
}

// handleSalesOrderConfirmed handles sales order confirmed events - reserves stock
func (s *EventSubscriber) handleSalesOrderConfirmed(msg *nats.Msg) <span class="cov0" title="0">{
        var event SalesOrderEvent
        if err := json.Unmarshal(msg.Data, &amp;event); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unmarshal sales order event", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">s.logger.Info("Received sales order confirmed event",
                zap.String("order_number", event.OrderNumber),
        )

        ctx := context.Background()

        // Reserve stock for each line item
        for _, item := range event.LineItems </span><span class="cov0" title="0">{
                input := &amp;reservation.CreateReservationInput{
                        MaterialID:      item.MaterialID,
                        Quantity:        item.Quantity,
                        UnitID:          item.UnitID,
                        ReservationType: entity.ReservationTypeSalesOrder,
                        ReferenceID:     event.OrderID,
                        ReferenceNumber: event.OrderNumber,
                        CreatedBy:       uuid.Nil, // System
                }

                _, err := s.reserveStockUC.Execute(ctx, input)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to reserve stock for sales order",
                                zap.String("order_number", event.OrderNumber),
                                zap.String("material_id", item.MaterialID.String()),
                                zap.Error(err),
                        )
                        // Publish reservation failed event
                        continue</span>
                }
        }

        <span class="cov0" title="0">s.logger.Info("Stock reserved for sales order",
                zap.String("order_number", event.OrderNumber),
                zap.Int("items", len(event.LineItems)),
        )</span>
}

// handleSalesOrderCancelled handles sales order cancelled - releases reservations
func (s *EventSubscriber) handleSalesOrderCancelled(msg *nats.Msg) <span class="cov0" title="0">{
        var event struct {
                OrderID       uuid.UUID   `json:"order_id"`
                OrderNumber   string      `json:"order_number"`
                ReservationIDs []uuid.UUID `json:"reservation_ids"`
        }

        if err := json.Unmarshal(msg.Data, &amp;event); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unmarshal sales order cancelled event", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">s.logger.Info("Received sales order cancelled event",
                zap.String("order_number", event.OrderNumber),
        )

        ctx := context.Background()

        // Release reservations
        for _, reservationID := range event.ReservationIDs </span><span class="cov0" title="0">{
                err := s.releaseReservationUC.Execute(ctx, reservationID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to release reservation",
                                zap.String("reservation_id", reservationID.String()),
                                zap.Error(err),
                        )
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("Reservations released for cancelled order",
                zap.String("order_number", event.OrderNumber),
        )</span>
}

// WorkOrderEvent represents a work order event from manufacturing
type WorkOrderEvent struct {
        WorkOrderID     uuid.UUID              `json:"work_order_id"`
        WorkOrderNumber string                 `json:"work_order_number"`
        ProductID       uuid.UUID              `json:"product_id"`
        Quantity        float64                `json:"quantity"`
        Materials       []WorkOrderMaterialEvent `json:"materials"`
}

// WorkOrderMaterialEvent represents a material requirement
type WorkOrderMaterialEvent struct {
        MaterialID uuid.UUID `json:"material_id"`
        Quantity   float64   `json:"quantity"`
        UnitID     uuid.UUID `json:"unit_id"`
}

// handleWorkOrderStarted handles work order started - reserves materials
func (s *EventSubscriber) handleWorkOrderStarted(msg *nats.Msg) <span class="cov0" title="0">{
        var event WorkOrderEvent
        if err := json.Unmarshal(msg.Data, &amp;event); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unmarshal work order event", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">s.logger.Info("Received work order started event",
                zap.String("wo_number", event.WorkOrderNumber),
        )

        ctx := context.Background()

        // Reserve materials for production
        for _, mat := range event.Materials </span><span class="cov0" title="0">{
                input := &amp;reservation.CreateReservationInput{
                        MaterialID:      mat.MaterialID,
                        Quantity:        mat.Quantity,
                        UnitID:          mat.UnitID,
                        ReservationType: entity.ReservationTypeWorkOrder,
                        ReferenceID:     event.WorkOrderID,
                        ReferenceNumber: event.WorkOrderNumber,
                        CreatedBy:       uuid.Nil, // System
                }

                _, err := s.reserveStockUC.Execute(ctx, input)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to reserve material for work order",
                                zap.String("wo_number", event.WorkOrderNumber),
                                zap.String("material_id", mat.MaterialID.String()),
                                zap.Error(err),
                        )
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("Materials reserved for work order",
                zap.String("wo_number", event.WorkOrderNumber),
                zap.Int("materials", len(event.Materials)),
        )</span>
}

// ReservationRepository interface for querying reservations
type ReservationRepository interface {
        GetByReferenceID(ctx context.Context, referenceID uuid.UUID) ([]*entity.StockReservation, error)
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package testmocks

import (
        "context"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/erp-cosmetics/wms-service/internal/infrastructure/event"
        "github.com/google/uuid"
        "github.com/stretchr/testify/mock"
)

// MockStockRepository is a mock implementation of repository.StockRepository
type MockStockRepository struct {
        mock.Mock
}

func (m *MockStockRepository) Create(ctx context.Context, stock *entity.Stock) error <span class="cov0" title="0">{
        args := m.Called(ctx, stock)
        return args.Error(0)
}</span>

func (m *MockStockRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.Stock, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*entity.Stock), args.Error(1)</span>
}

func (m *MockStockRepository) Update(ctx context.Context, stock *entity.Stock) error <span class="cov0" title="0">{
        args := m.Called(ctx, stock)
        return args.Error(0)
}</span>

func (m *MockStockRepository) GetAvailableStockFEFO(ctx context.Context, materialID uuid.UUID) ([]*entity.Stock, error) <span class="cov0" title="0">{
        args := m.Called(ctx, materialID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]*entity.Stock), args.Error(1)</span>
}

func (m *MockStockRepository) IssueStockFEFO(ctx context.Context, materialID uuid.UUID, quantity float64, createdBy uuid.UUID) ([]entity.LotIssued, error) <span class="cov0" title="0">{
        args := m.Called(ctx, materialID, quantity, createdBy)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]entity.LotIssued), args.Error(1)</span>
}

func (m *MockStockRepository) CreateMovement(ctx context.Context, movement *entity.StockMovement) error <span class="cov0" title="0">{
        args := m.Called(ctx, movement)
        return args.Error(0)
}</span>

func (m *MockStockRepository) GetNextMovementNumber(ctx context.Context, movementType entity.MovementType) (string, error) <span class="cov0" title="0">{
        args := m.Called(ctx, movementType)
        return args.String(0), args.Error(1)
}</span>

// Implement other methods
func (m *MockStockRepository) GetByLocation(ctx context.Context, locationID uuid.UUID) ([]*entity.Stock, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockStockRepository) GetByMaterial(ctx context.Context, materialID uuid.UUID) ([]*entity.Stock, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockStockRepository) GetByMaterialAndLot(ctx context.Context, materialID, lotID uuid.UUID) (*entity.Stock, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockStockRepository) GetByLocationMaterialLot(ctx context.Context, locationID, materialID uuid.UUID, lotID *uuid.UUID) (*entity.Stock, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockStockRepository) List(ctx context.Context, filter *repository.StockFilter) ([]*entity.Stock, int64, error) <span class="cov0" title="0">{ return nil, 0, nil }</span>
func (m *MockStockRepository) ReceiveStock(ctx context.Context, stock *entity.Stock, movement *entity.StockMovement) error <span class="cov0" title="0">{ 
        args := m.Called(ctx, stock, movement)
        return args.Error(0)
}</span>
func (m *MockStockRepository) IssueStock(ctx context.Context, stock *entity.Stock, movement *entity.StockMovement) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockStockRepository) TransferStock(ctx context.Context, fromStock, toStock *entity.Stock, movement *entity.StockMovement) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockStockRepository) AdjustStock(ctx context.Context, stock *entity.Stock, adjustmentQty float64, movement *entity.StockMovement) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockStockRepository) ReserveStock(ctx context.Context, materialID uuid.UUID, quantity float64, reservation *entity.StockReservation) error <span class="cov0" title="0">{
        args := m.Called(ctx, materialID, quantity, reservation)
        return args.Error(0)
}</span>
func (m *MockStockRepository) ReleaseReservation(ctx context.Context, reservationID uuid.UUID) error <span class="cov0" title="0">{
        args := m.Called(ctx, reservationID)
        return args.Error(0)
}</span>
func (m *MockStockRepository) GetMaterialSummary(ctx context.Context, materialID uuid.UUID) (*entity.StockSummary, error) <span class="cov0" title="0">{
        args := m.Called(ctx, materialID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*entity.StockSummary), args.Error(1)</span>
}
func (m *MockStockRepository) GetLowStockMaterials(ctx context.Context, threshold float64) ([]*entity.StockSummary, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockStockRepository) GetExpiringStock(ctx context.Context, days int) ([]*entity.Stock, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockStockRepository) GetMovementsByLot(ctx context.Context, lotID uuid.UUID) ([]*entity.StockMovement, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockStockRepository) GetMovementsByMaterial(ctx context.Context, materialID uuid.UUID, limit int) ([]*entity.StockMovement, error) <span class="cov0" title="0">{ return nil, nil }</span>

// MockGoodsIssueRepository
type MockGoodsIssueRepository struct {
        mock.Mock
}

func (m *MockGoodsIssueRepository) Create(ctx context.Context, issue *entity.GoodsIssue) error <span class="cov0" title="0">{
        args := m.Called(ctx, issue)
        return args.Error(0)
}</span>
func (m *MockGoodsIssueRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.GoodsIssue, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockGoodsIssueRepository) GetByNumber(ctx context.Context, num string) (*entity.GoodsIssue, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockGoodsIssueRepository) List(ctx context.Context, filter *repository.GoodsIssueFilter) ([]*entity.GoodsIssue, int64, error) <span class="cov0" title="0">{ return nil, 0, nil }</span>
func (m *MockGoodsIssueRepository) Update(ctx context.Context, issue *entity.GoodsIssue) error <span class="cov0" title="0">{
        args := m.Called(ctx, issue)
        return args.Error(0)
}</span>
func (m *MockGoodsIssueRepository) GetNextIssueNumber(ctx context.Context) (string, error) <span class="cov0" title="0">{
        args := m.Called(ctx)
        return args.String(0), args.Error(1)
}</span>
func (m *MockGoodsIssueRepository) CreateLineItem(ctx context.Context, item *entity.GILineItem) error <span class="cov0" title="0">{
        args := m.Called(ctx, item)
        return args.Error(0)
}</span>
func (m *MockGoodsIssueRepository) CreateLineItems(ctx context.Context, items []*entity.GILineItem) error <span class="cov0" title="0">{
        args := m.Called(ctx, items)
        return args.Error(0)
}</span>
func (m *MockGoodsIssueRepository) GetLineItemsByIssueID(ctx context.Context, id uuid.UUID) ([]*entity.GILineItem, error) <span class="cov0" title="0">{ return nil, nil }</span>

// MockGRNRepository
type MockGRNRepository struct {
        mock.Mock
}

func (m *MockGRNRepository) Create(ctx context.Context, grn *entity.GRN) error <span class="cov0" title="0">{
        args := m.Called(ctx, grn)
        return args.Error(0)
}</span>
func (m *MockGRNRepository) Update(ctx context.Context, grn *entity.GRN) error <span class="cov0" title="0">{
        args := m.Called(ctx, grn)
        return args.Error(0)
}</span>
func (m *MockGRNRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.GRN, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*entity.GRN), args.Error(1)</span>
}
func (m *MockGRNRepository) GetByNumber(ctx context.Context, num string) (*entity.GRN, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockGRNRepository) GetByPOID(ctx context.Context, poID uuid.UUID) ([]*entity.GRN, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockGRNRepository) CreateLineItem(ctx context.Context, item *entity.GRNLineItem) error <span class="cov0" title="0">{ 
        args := m.Called(ctx, item)
        return args.Error(0)
}</span>
func (m *MockGRNRepository) GetNextGRNNumber(ctx context.Context) (string, error) <span class="cov0" title="0">{
        args := m.Called(ctx)
        return args.String(0), args.Error(1)
}</span>
func (m *MockGRNRepository) List(ctx context.Context, filter *repository.GRNFilter) ([]*entity.GRN, int64, error) <span class="cov0" title="0">{ return nil, 0, nil }</span>
func (m *MockGRNRepository) GetLineItemsByGRNID(ctx context.Context, grnID uuid.UUID) ([]*entity.GRNLineItem, error) <span class="cov0" title="0">{
        args := m.Called(ctx, grnID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]*entity.GRNLineItem), args.Error(1)</span>
}
func (m *MockGRNRepository) UpdateLineItem(ctx context.Context, item *entity.GRNLineItem) error <span class="cov0" title="0">{
        args := m.Called(ctx, item)
        return args.Error(0)
}</span>

// MockZoneRepository
type MockZoneRepository struct {
        mock.Mock
}

func (m *MockZoneRepository) GetQuarantineZone(ctx context.Context, whID uuid.UUID) (*entity.Zone, error) <span class="cov0" title="0">{
        args := m.Called(ctx, whID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*entity.Zone), args.Error(1)</span>
}
func (m *MockZoneRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.Zone, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockZoneRepository) GetByWarehouseID(ctx context.Context, whID uuid.UUID) ([]*entity.Zone, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockZoneRepository) GetStorageZone(ctx context.Context, whID uuid.UUID) (*entity.Zone, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockZoneRepository) Create(ctx context.Context, zone *entity.Zone) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockZoneRepository) Update(ctx context.Context, zone *entity.Zone) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockZoneRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{ return nil }</span>

// MockLocationRepository
type MockLocationRepository struct {
        mock.Mock
}

func (m *MockLocationRepository) GetByZoneID(ctx context.Context, zoneID uuid.UUID) ([]*entity.Location, error) <span class="cov0" title="0">{
        args := m.Called(ctx, zoneID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]*entity.Location), args.Error(1)</span>
}
func (m *MockLocationRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.Location, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockLocationRepository) GetByCode(ctx context.Context, zID uuid.UUID, code string) (*entity.Location, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockLocationRepository) Create(ctx context.Context, location *entity.Location) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockLocationRepository) Update(ctx context.Context, location *entity.Location) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockLocationRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{ return nil }</span>

// MockLotRepository
type MockLotRepository struct {
        mock.Mock
}

func (m *MockLotRepository) Create(ctx context.Context, lot *entity.Lot) error <span class="cov0" title="0">{
        args := m.Called(ctx, lot)
        return args.Error(0)
}</span>
func (m *MockLotRepository) Update(ctx context.Context, lot *entity.Lot) error <span class="cov0" title="0">{
        args := m.Called(ctx, lot)
        return args.Error(0)
}</span>
func (m *MockLotRepository) GetByID(ctx context.Context, id uuid.UUID) (*entity.Lot, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*entity.Lot), args.Error(1)</span>
}
func (m *MockLotRepository) GetByLotNumber(ctx context.Context, num string) (*entity.Lot, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockLotRepository) List(ctx context.Context, filter *repository.LotFilter) ([]*entity.Lot, int64, error) <span class="cov0" title="0">{ return nil, 0, nil }</span>
func (m *MockLotRepository) GetAvailableLots(ctx context.Context, matID uuid.UUID) ([]*entity.Lot, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockLotRepository) GetExpiringLots(ctx context.Context, days int) ([]*entity.Lot, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockLotRepository) GetExpiredLots(ctx context.Context) ([]*entity.Lot, error) <span class="cov0" title="0">{ return nil, nil }</span>
func (m *MockLotRepository) GetNextLotNumber(ctx context.Context) (string, error) <span class="cov0" title="0">{
        args := m.Called(ctx)
        return args.String(0), args.Error(1)
}</span>
func (m *MockLotRepository) MarkExpired(ctx context.Context, ids []uuid.UUID) error <span class="cov0" title="0">{ return nil }</span>

// MockEventPublisher
type MockEventPublisher struct {
        mock.Mock
}

func (m *MockEventPublisher) PublishGRNCreated(e *event.GRNCreatedEvent) error <span class="cov0" title="0">{
        args := m.Called(e)
        return args.Error(0)
}</span>
func (m *MockEventPublisher) PublishGRNCompleted(e *event.GRNCompletedEvent) error <span class="cov0" title="0">{
        args := m.Called(e)
        return args.Error(0)
}</span>
func (m *MockEventPublisher) PublishStockReceived(e *event.StockReceivedEvent) error <span class="cov0" title="0">{
        args := m.Called(e)
        return args.Error(0)
}</span>
func (m *MockEventPublisher) PublishStockIssued(e *event.StockIssuedEvent) error <span class="cov0" title="0">{
        args := m.Called(e)
        return args.Error(0)
}</span>
func (m *MockEventPublisher) PublishStockReserved(e *event.StockReservedEvent) error <span class="cov0" title="0">{
        args := m.Called(e)
        return args.Error(0)
}</span>
func (m *MockEventPublisher) PublishLowStockAlert(e *event.LowStockAlertEvent) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockEventPublisher) PublishLotExpiringSoon(e *event.LotExpiringEvent) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockEventPublisher) PublishLotExpired(e *event.LotExpiringEvent) error <span class="cov0" title="0">{ return nil }</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package testutils

import (
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/google/uuid"
)

// LotBuilder helps created test Lot entities
type LotBuilder struct {
        lot *entity.Lot
}

func NewLotBuilder() *LotBuilder <span class="cov0" title="0">{
        return &amp;LotBuilder{
                lot: &amp;entity.Lot{
                        ID:           uuid.New(),
                        LotNumber:    "LOT-" + uuid.New().String()[:8],
                        QCStatus:     entity.QCStatusPassed,
                        Status:       entity.LotStatusAvailable,
                        ReceivedDate: time.Now(),
                        ExpiryDate:   time.Now().AddDate(0, 0, 365),
                        CreatedAt:    time.Now(),
                        UpdatedAt:    time.Now(),
                },
        }
}</span>

func (b *LotBuilder) WithID(id uuid.UUID) *LotBuilder <span class="cov0" title="0">{
        b.lot.ID = id
        return b
}</span>

func (b *LotBuilder) WithLotNumber(n string) *LotBuilder <span class="cov0" title="0">{
        b.lot.LotNumber = n
        return b
}</span>

func (b *LotBuilder) WithMaterialID(id uuid.UUID) *LotBuilder <span class="cov0" title="0">{
        b.lot.MaterialID = id
        return b
}</span>

func (b *LotBuilder) WithExpiry(date time.Time) *LotBuilder <span class="cov0" title="0">{
        b.lot.ExpiryDate = date
        return b
}</span>

func (b *LotBuilder) WithQCStatus(status entity.QCStatus) *LotBuilder <span class="cov0" title="0">{
        b.lot.QCStatus = status
        return b
}</span>

func (b *LotBuilder) WithStatus(status entity.LotStatus) *LotBuilder <span class="cov0" title="0">{
        b.lot.Status = status
        return b
}</span>

func (b *LotBuilder) Build() *entity.Lot <span class="cov0" title="0">{
        return b.lot
}</span>

// StockBuilder helps create test Stock entities
type StockBuilder struct {
        stock *entity.Stock
}

func NewStockBuilder() *StockBuilder <span class="cov0" title="0">{
        return &amp;StockBuilder{
                stock: &amp;entity.Stock{
                        ID:          uuid.New(),
                        WarehouseID: uuid.New(),
                        ZoneID:      uuid.New(),
                        LocationID:  uuid.New(),
                        Quantity:    100,
                        ReservedQty: 0,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
        }
}</span>

func (b *StockBuilder) WithLocation(id uuid.UUID) *StockBuilder <span class="cov0" title="0">{
        b.stock.LocationID = id
        return b
}</span>

func (b *StockBuilder) WithMaterial(id uuid.UUID) *StockBuilder <span class="cov0" title="0">{
        b.stock.MaterialID = id
        return b
}</span>

func (b *StockBuilder) WithLot(lot *entity.Lot) *StockBuilder <span class="cov0" title="0">{
        if lot != nil </span><span class="cov0" title="0">{
                b.stock.LotID = &amp;lot.ID
                b.stock.Lot = lot
                b.stock.MaterialID = lot.MaterialID
        }</span>
        <span class="cov0" title="0">return b</span>
}

func (b *StockBuilder) WithQuantity(qty float64) *StockBuilder <span class="cov0" title="0">{
        b.stock.Quantity = qty
        b.stock.AvailableQty = qty - b.stock.ReservedQty
        return b
}</span>

func (b *StockBuilder) WithReserved(qty float64) *StockBuilder <span class="cov0" title="0">{
        b.stock.ReservedQty = qty
        b.stock.AvailableQty = b.stock.Quantity - qty
        return b
}</span>

func (b *StockBuilder) Build() *entity.Stock <span class="cov0" title="0">{
        b.stock.AvailableQty = b.stock.Quantity - b.stock.ReservedQty
        return b.stock
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package adjustment

import (
        "context"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/google/uuid"
)

// AdjustmentType defines types of adjustments
type AdjustmentType string

const (
        AdjustmentTypeCycleCount AdjustmentType = "CYCLE_COUNT"
        AdjustmentTypeDamage     AdjustmentType = "DAMAGE"
        AdjustmentTypeExpiry     AdjustmentType = "EXPIRY"
        AdjustmentTypeCorrection AdjustmentType = "CORRECTION"
)

// CreateAdjustmentUseCase handles stock adjustments
type CreateAdjustmentUseCase struct {
        stockRepo repository.StockRepository
}

// NewCreateAdjustmentUseCase creates a new use case
func NewCreateAdjustmentUseCase(stockRepo repository.StockRepository) *CreateAdjustmentUseCase <span class="cov0" title="0">{
        return &amp;CreateAdjustmentUseCase{stockRepo: stockRepo}
}</span>

// CreateAdjustmentInput represents input for creating adjustment
type CreateAdjustmentInput struct {
        AdjustmentDate time.Time
        AdjustmentType AdjustmentType
        LocationID     uuid.UUID
        MaterialID     uuid.UUID
        LotID          *uuid.UUID
        UnitID         uuid.UUID
        SystemQty      float64
        ActualQty      float64
        Reason         string
        Notes          string
        AdjustedBy     uuid.UUID
}

// CreateAdjustmentOutput represents adjustment output
type CreateAdjustmentOutput struct {
        AdjustmentNumber string
        Variance         float64
        MovementNumber   string
}

// Execute creates a stock adjustment
func (uc *CreateAdjustmentUseCase) Execute(ctx context.Context, input *CreateAdjustmentInput) (*CreateAdjustmentOutput, error) <span class="cov0" title="0">{
        // Calculate variance
        variance := input.ActualQty - input.SystemQty

        // Get stock record
        stock, err := uc.stockRepo.GetByLocationMaterialLot(ctx, input.LocationID, input.MaterialID, input.LotID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create movement record
        <span class="cov0" title="0">movementNumber, err := uc.stockRepo.GetNextMovementNumber(ctx, entity.MovementTypeAdjustment)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">movement := &amp;entity.StockMovement{
                MovementNumber:  movementNumber,
                MovementType:    entity.MovementTypeAdjustment,
                ReferenceType:   entity.ReferenceTypeAdjustment,
                MaterialID:      input.MaterialID,
                LotID:           input.LotID,
                FromLocationID:  &amp;input.LocationID,
                ToLocationID:    &amp;input.LocationID,
                Quantity:        variance, // Can be negative
                UnitID:          input.UnitID,
                Notes:           input.Notes,
                CreatedBy:       input.AdjustedBy,
        }

        // Adjust stock
        if err := uc.stockRepo.AdjustStock(ctx, stock, variance, movement); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;CreateAdjustmentOutput{
                AdjustmentNumber: movementNumber,
                Variance:         variance,
                MovementNumber:   movementNumber,
        }, nil</span>
}

// TransferStockUseCase handles stock transfers between locations
type TransferStockUseCase struct {
        stockRepo repository.StockRepository
}

// NewTransferStockUseCase creates a new use case
func NewTransferStockUseCase(stockRepo repository.StockRepository) *TransferStockUseCase <span class="cov0" title="0">{
        return &amp;TransferStockUseCase{stockRepo: stockRepo}
}</span>

// TransferStockInput represents input for transferring stock
type TransferStockInput struct {
        MaterialID     uuid.UUID
        LotID          *uuid.UUID
        FromLocationID uuid.UUID
        ToLocationID   uuid.UUID
        Quantity       float64
        UnitID         uuid.UUID
        Reason         string
        TransferredBy  uuid.UUID
}

// Execute transfers stock between locations
func (uc *TransferStockUseCase) Execute(ctx context.Context, input *TransferStockInput) (string, error) <span class="cov0" title="0">{
        // Get source stock
        fromStock, err := uc.stockRepo.GetByLocationMaterialLot(ctx, input.FromLocationID, input.MaterialID, input.LotID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Check availability
        <span class="cov0" title="0">if fromStock.Quantity-fromStock.ReservedQty &lt; input.Quantity </span><span class="cov0" title="0">{
                return "", entity.ErrInsufficientStock
        }</span>

        // Deduct from source
        <span class="cov0" title="0">fromStock.Quantity -= input.Quantity

        // Create destination stock
        toStock := &amp;entity.Stock{
                WarehouseID: fromStock.WarehouseID,
                ZoneID:      fromStock.ZoneID, // Will be updated based on location
                LocationID:  input.ToLocationID,
                MaterialID:  input.MaterialID,
                LotID:       input.LotID,
                Quantity:    input.Quantity,
                UnitID:      input.UnitID,
        }

        // Create movement
        movementNumber, _ := uc.stockRepo.GetNextMovementNumber(ctx, entity.MovementTypeTransfer)
        movement := entity.NewStockMovementTransfer(
                input.MaterialID,
                input.LotID,
                input.FromLocationID,
                input.ToLocationID,
                input.UnitID,
                input.TransferredBy,
                input.Quantity,
                movementNumber,
        )
        movement.Notes = input.Reason

        // Execute transfer
        if err := uc.stockRepo.TransferStock(ctx, fromStock, toStock, movement); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return movementNumber, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package grn

import (
        "context"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/erp-cosmetics/wms-service/internal/infrastructure/event"
        "github.com/google/uuid"
)

// EventPublisher defines event publishing interface for GRN
type EventPublisher interface {
        PublishGRNCreated(event *event.GRNCreatedEvent) error
        PublishGRNCompleted(event *event.GRNCompletedEvent) error
        PublishStockReceived(event *event.StockReceivedEvent) error
}

// CreateGRNUseCase handles GRN creation
type CreateGRNUseCase struct {
        grnRepo      repository.GRNRepository
        lotRepo      repository.LotRepository
        stockRepo    repository.StockRepository
        zoneRepo     repository.ZoneRepository
        locationRepo repository.LocationRepository
        eventPub     EventPublisher
}

// NewCreateGRNUseCase creates a new use case
func NewCreateGRNUseCase(
        grnRepo repository.GRNRepository,
        lotRepo repository.LotRepository,
        stockRepo repository.StockRepository,
        zoneRepo repository.ZoneRepository,
        locationRepo repository.LocationRepository,
        eventPub EventPublisher,
) *CreateGRNUseCase <span class="cov8" title="1">{
        return &amp;CreateGRNUseCase{
                grnRepo:      grnRepo,
                lotRepo:      lotRepo,
                stockRepo:    stockRepo,
                zoneRepo:     zoneRepo,
                locationRepo: locationRepo,
                eventPub:     eventPub,
        }
}</span>

// CreateGRNInput represents input for creating GRN
type CreateGRNInput struct {
        GRNDate            time.Time
        POID               *uuid.UUID
        PONumber           string
        SupplierID         *uuid.UUID
        WarehouseID        uuid.UUID
        DeliveryNoteNumber string
        VehicleNumber      string
        Notes              string
        ReceivedBy         uuid.UUID
        Items              []CreateGRNItemInput
}

// CreateGRNItemInput represents input for GRN line item
type CreateGRNItemInput struct {
        POLineItemID      *uuid.UUID
        MaterialID        uuid.UUID
        ExpectedQty       *float64
        ReceivedQty       float64
        UnitID            uuid.UUID
        SupplierLotNumber string
        ManufacturedDate  *time.Time
        ExpiryDate        time.Time
        LocationID        *uuid.UUID
}

// Execute creates a GRN
func (uc *CreateGRNUseCase) Execute(ctx context.Context, input *CreateGRNInput) (*entity.GRN, error) <span class="cov8" title="1">{
        // Generate GRN number
        grnNumber, err := uc.grnRepo.GetNextGRNNumber(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get quarantine zone for initial placement
        <span class="cov8" title="1">quarantineZone, _ := uc.zoneRepo.GetQuarantineZone(ctx, input.WarehouseID)
        var defaultLocationID *uuid.UUID
        if quarantineZone != nil </span><span class="cov8" title="1">{
                locations, _ := uc.locationRepo.GetByZoneID(ctx, quarantineZone.ID)
                if len(locations) &gt; 0 </span><span class="cov8" title="1">{
                        defaultLocationID = &amp;locations[0].ID
                }</span>
        }

        // Create GRN
        <span class="cov8" title="1">grn := &amp;entity.GRN{
                GRNNumber:          grnNumber,
                GRNDate:            input.GRNDate,
                POID:               input.POID,
                PONumber:           input.PONumber,
                SupplierID:         input.SupplierID,
                WarehouseID:        input.WarehouseID,
                DeliveryNoteNumber: input.DeliveryNoteNumber,
                VehicleNumber:      input.VehicleNumber,
                Status:             entity.GRNStatusDraft,
                QCStatus:           entity.QCStatusPending,
                Notes:              input.Notes,
                ReceivedBy:         &amp;input.ReceivedBy,
        }

        if err := uc.grnRepo.Create(ctx, grn); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create line items with lots
        <span class="cov8" title="1">for i, item := range input.Items </span><span class="cov8" title="1">{
                // Generate lot number
                lotNumber, err := uc.lotRepo.GetNextLotNumber(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Create lot
                <span class="cov8" title="1">lot := &amp;entity.Lot{
                        LotNumber:         lotNumber,
                        MaterialID:        item.MaterialID,
                        SupplierID:        input.SupplierID,
                        SupplierLotNumber: item.SupplierLotNumber,
                        ManufacturedDate:  item.ManufacturedDate,
                        ExpiryDate:        item.ExpiryDate,
                        ReceivedDate:      input.GRNDate,
                        GRNID:             &amp;grn.ID,
                        QCStatus:          entity.QCStatusPending,
                        Status:            entity.LotStatusAvailable,
                }

                if err := uc.lotRepo.Create(ctx, lot); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Determine location
                <span class="cov8" title="1">locationID := item.LocationID
                if locationID == nil &amp;&amp; defaultLocationID != nil </span><span class="cov8" title="1">{
                        locationID = defaultLocationID
                }</span>

                // Create GRN line item
                <span class="cov8" title="1">lineItem := &amp;entity.GRNLineItem{
                        GRNID:             grn.ID,
                        LineNumber:        i + 1,
                        POLineItemID:      item.POLineItemID,
                        MaterialID:        item.MaterialID,
                        ExpectedQty:       item.ExpectedQty,
                        ReceivedQty:       item.ReceivedQty,
                        UnitID:            item.UnitID,
                        LotID:             &amp;lot.ID,
                        SupplierLotNumber: item.SupplierLotNumber,
                        ManufacturedDate:  item.ManufacturedDate,
                        ExpiryDate:        item.ExpiryDate,
                        LocationID:        locationID,
                        QCStatus:          entity.QCStatusPending,
                }

                if err := uc.grnRepo.CreateLineItem(ctx, lineItem); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Publish event
        <span class="cov8" title="1">poID := ""
        if input.POID != nil </span><span class="cov0" title="0">{
                poID = input.POID.String()
        }</span>
        <span class="cov8" title="1">uc.eventPub.PublishGRNCreated(&amp;event.GRNCreatedEvent{
                GRNID:     grn.ID.String(),
                GRNNumber: grnNumber,
                POID:      poID,
        })

        return grn, nil</span>
}

// CompleteGRNUseCase handles completing GRN after QC
type CompleteGRNUseCase struct {
        grnRepo   repository.GRNRepository
        lotRepo   repository.LotRepository
        stockRepo repository.StockRepository
        zoneRepo  repository.ZoneRepository
        eventPub  EventPublisher
}

// NewCompleteGRNUseCase creates a new use case
func NewCompleteGRNUseCase(
        grnRepo repository.GRNRepository,
        lotRepo repository.LotRepository,
        stockRepo repository.StockRepository,
        zoneRepo repository.ZoneRepository,
        eventPub EventPublisher,
) *CompleteGRNUseCase <span class="cov8" title="1">{
        return &amp;CompleteGRNUseCase{
                grnRepo:   grnRepo,
                lotRepo:   lotRepo,
                stockRepo: stockRepo,
                zoneRepo:  zoneRepo,
                eventPub:  eventPub,
        }
}</span>

// CompleteGRNInput represents input for completing GRN
type CompleteGRNInput struct {
        GRNID    uuid.UUID
        QCStatus entity.QCStatus
        QCNotes  string
}

// Execute completes the GRN after QC
func (uc *CompleteGRNUseCase) Execute(ctx context.Context, input *CompleteGRNInput) (*entity.GRN, error) <span class="cov8" title="1">{
        // Get GRN
        grn, err := uc.grnRepo.GetByID(ctx, input.GRNID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !grn.CanComplete() </span><span class="cov0" title="0">{
                return nil, entity.ErrAlreadyCompleted
        }</span>

        // Get line items
        <span class="cov8" title="1">items, err := uc.grnRepo.GetLineItemsByGRNID(ctx, grn.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Process each line item
        <span class="cov8" title="1">eventItems := make([]event.GRNCompletedEventItem, 0)
        for _, item := range items </span><span class="cov8" title="1">{
                // Update lot QC status
                if item.LotID != nil </span><span class="cov8" title="1">{
                        lot, err := uc.lotRepo.GetByID(ctx, *item.LotID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">if input.QCStatus == entity.QCStatusPassed </span><span class="cov8" title="1">{
                                lot.PassQC()
                                item.PassQC(item.ReceivedQty)
                        }</span> else<span class="cov0" title="0"> {
                                lot.FailQC()
                                item.FailQC(input.QCNotes)
                        }</span>

                        <span class="cov8" title="1">if err := uc.lotRepo.Update(ctx, lot); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Create stock if QC passed
                        <span class="cov8" title="1">if input.QCStatus == entity.QCStatusPassed &amp;&amp; item.LocationID != nil </span><span class="cov8" title="1">{
                                location, _ := uc.stockRepo.GetByID(ctx, *item.LocationID)
                                
                                stock := &amp;entity.Stock{
                                        WarehouseID: grn.WarehouseID,
                                        ZoneID:      location.ZoneID,
                                        LocationID:  *item.LocationID,
                                        MaterialID:  item.MaterialID,
                                        LotID:       item.LotID,
                                        Quantity:    item.ReceivedQty,
                                        UnitID:      item.UnitID,
                                }

                                movementNumber, _ := uc.stockRepo.GetNextMovementNumber(ctx, entity.MovementTypeIn)
                                movement := entity.NewStockMovementIn(
                                        item.MaterialID,
                                        *item.LotID,
                                        *item.LocationID,
                                        item.UnitID,
                                        *grn.ReceivedBy,
                                        item.ReceivedQty,
                                        entity.ReferenceTypeGRN,
                                        &amp;grn.ID,
                                        movementNumber,
                                )

                                if err := uc.stockRepo.ReceiveStock(ctx, stock, movement); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                // Publish stock received event
                                <span class="cov8" title="1">uc.eventPub.PublishStockReceived(&amp;event.StockReceivedEvent{
                                        MaterialID:  item.MaterialID.String(),
                                        LotID:       item.LotID.String(),
                                        Quantity:    item.ReceivedQty,
                                        LocationID:  item.LocationID.String(),
                                        WarehouseID: grn.WarehouseID.String(),
                                })</span>
                        }

                        // Add to event items
                        <span class="cov8" title="1">acceptedQty := 0.0
                        if item.AcceptedQty != nil </span><span class="cov8" title="1">{
                                acceptedQty = *item.AcceptedQty
                        }</span>
                        <span class="cov8" title="1">eventItems = append(eventItems, event.GRNCompletedEventItem{
                                MaterialID:  item.MaterialID.String(),
                                LotID:       item.LotID.String(),
                                LotNumber:   lot.LotNumber,
                                ReceivedQty: item.ReceivedQty,
                                AcceptedQty: acceptedQty,
                        })</span>
                }

                // Update line item
                <span class="cov8" title="1">if err := uc.grnRepo.UpdateLineItem(ctx, item); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Complete GRN
        <span class="cov8" title="1">grn.Complete(input.QCStatus, input.QCNotes)
        if err := uc.grnRepo.Update(ctx, grn); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Publish GRN completed event (Procurement will update PO)
        <span class="cov8" title="1">poID := ""
        if grn.POID != nil </span><span class="cov0" title="0">{
                poID = grn.POID.String()
        }</span>
        <span class="cov8" title="1">uc.eventPub.PublishGRNCompleted(&amp;event.GRNCompletedEvent{
                GRNID:       grn.ID.String(),
                GRNNumber:   grn.GRNNumber,
                POID:        poID,
                WarehouseID: grn.WarehouseID.String(),
                Items:       eventItems,
        })

        return grn, nil</span>
}

// GetGRNUseCase handles getting GRN
type GetGRNUseCase struct {
        grnRepo repository.GRNRepository
}

// NewGetGRNUseCase creates a new use case
func NewGetGRNUseCase(grnRepo repository.GRNRepository) *GetGRNUseCase <span class="cov0" title="0">{
        return &amp;GetGRNUseCase{grnRepo: grnRepo}
}</span>

// Execute gets a GRN by ID
func (uc *GetGRNUseCase) Execute(ctx context.Context, id uuid.UUID) (*entity.GRN, error) <span class="cov0" title="0">{
        return uc.grnRepo.GetByID(ctx, id)
}</span>

// ListGRNsUseCase handles listing GRNs
type ListGRNsUseCase struct {
        grnRepo repository.GRNRepository
}

// NewListGRNsUseCase creates a new use case
func NewListGRNsUseCase(grnRepo repository.GRNRepository) *ListGRNsUseCase <span class="cov0" title="0">{
        return &amp;ListGRNsUseCase{grnRepo: grnRepo}
}</span>

// Execute lists GRNs
func (uc *ListGRNsUseCase) Execute(ctx context.Context, filter *repository.GRNFilter) ([]*entity.GRN, int64, error) <span class="cov0" title="0">{
        return uc.grnRepo.List(ctx, filter)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package inventory

import (
        "context"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/google/uuid"
)

// CreateInventoryCountUseCase handles creating inventory count
type CreateInventoryCountUseCase struct {
        countRepo    repository.InventoryCountRepository
        stockRepo    repository.StockRepository
        locationRepo repository.LocationRepository
}

// NewCreateInventoryCountUseCase creates a new use case
func NewCreateInventoryCountUseCase(
        countRepo repository.InventoryCountRepository,
        stockRepo repository.StockRepository,
        locationRepo repository.LocationRepository,
) *CreateInventoryCountUseCase <span class="cov0" title="0">{
        return &amp;CreateInventoryCountUseCase{
                countRepo:    countRepo,
                stockRepo:    stockRepo,
                locationRepo: locationRepo,
        }
}</span>

// CreateInventoryCountInput represents input for creating inventory count
type CreateInventoryCountInput struct {
        CountDate   time.Time
        CountType   entity.InventoryCountType
        WarehouseID uuid.UUID
        ZoneID      *uuid.UUID
        Notes       string
        CreatedBy   uuid.UUID
}

// Execute creates an inventory count with line items from current stock
func (uc *CreateInventoryCountUseCase) Execute(ctx context.Context, input *CreateInventoryCountInput) (*entity.InventoryCount, error) <span class="cov0" title="0">{
        // Generate count number
        countNumber, err := uc.countRepo.GetNextCountNumber(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create inventory count
        <span class="cov0" title="0">count := &amp;entity.InventoryCount{
                CountNumber: countNumber,
                CountDate:   input.CountDate,
                CountType:   input.CountType,
                WarehouseID: input.WarehouseID,
                ZoneID:      input.ZoneID,
                Status:      entity.InventoryCountStatusDraft,
                Notes:       input.Notes,
                CreatedBy:   input.CreatedBy,
        }

        if err := uc.countRepo.Create(ctx, count); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get stock for the warehouse/zone and create line items
        <span class="cov0" title="0">filter := &amp;repository.StockFilter{
                WarehouseID: &amp;input.WarehouseID,
        }
        if input.ZoneID != nil </span><span class="cov0" title="0">{
                filter.ZoneID = input.ZoneID
        }</span>
        <span class="cov0" title="0">hasStock := true
        filter.HasStock = &amp;hasStock

        stocks, _, err := uc.stockRepo.List(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var lineItems []*entity.InventoryCountLineItem
        for _, stock := range stocks </span><span class="cov0" title="0">{
                lineItem := &amp;entity.InventoryCountLineItem{
                        InventoryCountID: count.ID,
                        LocationID:       stock.LocationID,
                        MaterialID:       stock.MaterialID,
                        LotID:            stock.LotID,
                        UnitID:           stock.UnitID,
                        SystemQty:        stock.Quantity,
                        IsCounted:        false,
                }
                lineItems = append(lineItems, lineItem)
        }</span>

        <span class="cov0" title="0">if len(lineItems) &gt; 0 </span><span class="cov0" title="0">{
                if err := uc.countRepo.CreateLineItems(ctx, lineItems); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return count, nil</span>
}

// StartInventoryCountUseCase handles starting inventory count
type StartInventoryCountUseCase struct {
        countRepo repository.InventoryCountRepository
}

// NewStartInventoryCountUseCase creates a new use case
func NewStartInventoryCountUseCase(countRepo repository.InventoryCountRepository) *StartInventoryCountUseCase <span class="cov0" title="0">{
        return &amp;StartInventoryCountUseCase{countRepo: countRepo}
}</span>

// Execute starts the inventory count
func (uc *StartInventoryCountUseCase) Execute(ctx context.Context, countID uuid.UUID) (*entity.InventoryCount, error) <span class="cov0" title="0">{
        count, err := uc.countRepo.GetByID(ctx, countID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !count.CanStart() </span><span class="cov0" title="0">{
                return nil, entity.ErrInvalidStatus
        }</span>

        <span class="cov0" title="0">count.Start()
        if err := uc.countRepo.Update(ctx, count); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// RecordCountUseCase handles recording a count
type RecordCountUseCase struct {
        countRepo repository.InventoryCountRepository
}

// NewRecordCountUseCase creates a new use case
func NewRecordCountUseCase(countRepo repository.InventoryCountRepository) *RecordCountUseCase <span class="cov0" title="0">{
        return &amp;RecordCountUseCase{countRepo: countRepo}
}</span>

// RecordCountInput represents input for recording a count
type RecordCountInput struct {
        LineItemID uuid.UUID
        CountedQty float64
        CountedBy  uuid.UUID
        Notes      string
}

// Execute records the counted quantity
func (uc *RecordCountUseCase) Execute(ctx context.Context, input *RecordCountInput) (*entity.InventoryCountLineItem, error) <span class="cov0" title="0">{
        items, err := uc.countRepo.GetLineItemsByCountID(ctx, input.LineItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var lineItem *entity.InventoryCountLineItem
        for _, item := range items </span><span class="cov0" title="0">{
                if item.ID == input.LineItemID </span><span class="cov0" title="0">{
                        lineItem = item
                        break</span>
                }
        }

        <span class="cov0" title="0">if lineItem == nil </span><span class="cov0" title="0">{
                return nil, entity.ErrNotFound
        }</span>

        <span class="cov0" title="0">lineItem.RecordCount(input.CountedQty, input.CountedBy)
        lineItem.Notes = input.Notes

        if err := uc.countRepo.UpdateLineItem(ctx, lineItem); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return lineItem, nil</span>
}

// CompleteInventoryCountUseCase handles completing inventory count
type CompleteInventoryCountUseCase struct {
        countRepo repository.InventoryCountRepository
        stockRepo repository.StockRepository
}

// NewCompleteInventoryCountUseCase creates a new use case
func NewCompleteInventoryCountUseCase(
        countRepo repository.InventoryCountRepository,
        stockRepo repository.StockRepository,
) *CompleteInventoryCountUseCase <span class="cov0" title="0">{
        return &amp;CompleteInventoryCountUseCase{
                countRepo: countRepo,
                stockRepo: stockRepo,
        }
}</span>

// CompleteInventoryCountInput represents input for completing count
type CompleteInventoryCountInput struct {
        CountID       uuid.UUID
        ApplyVariance bool // If true, adjust stock based on variance
        ApprovedBy    uuid.UUID
}

// Execute completes the inventory count
func (uc *CompleteInventoryCountUseCase) Execute(ctx context.Context, input *CompleteInventoryCountInput) (*entity.InventoryCount, error) <span class="cov0" title="0">{
        count, err := uc.countRepo.GetByID(ctx, input.CountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !count.CanComplete() </span><span class="cov0" title="0">{
                return nil, entity.ErrInvalidStatus
        }</span>

        // Check all items are counted
        <span class="cov0" title="0">pending, err := uc.countRepo.GetPendingItems(ctx, count.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(pending) &gt; 0 </span><span class="cov0" title="0">{
                return nil, entity.ErrPendingItems
        }</span>

        // Apply variance if requested
        <span class="cov0" title="0">if input.ApplyVariance </span><span class="cov0" title="0">{
                varianceItems, err := uc.countRepo.GetVarianceItems(ctx, count.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, item := range varianceItems </span><span class="cov0" title="0">{
                        // Get stock and adjust
                        stock, err := uc.stockRepo.GetByLocationMaterialLot(ctx, item.LocationID, item.MaterialID, item.LotID)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">movementNumber, _ := uc.stockRepo.GetNextMovementNumber(ctx, entity.MovementTypeAdjustment)
                        movement := &amp;entity.StockMovement{
                                MovementNumber: movementNumber,
                                MovementType:   entity.MovementTypeAdjustment,
                                ReferenceType:  entity.ReferenceTypeAdjustment,
                                ReferenceID:    &amp;count.ID,
                                MaterialID:     item.MaterialID,
                                LotID:          item.LotID,
                                FromLocationID: &amp;item.LocationID,
                                ToLocationID:   &amp;item.LocationID,
                                Quantity:       item.Variance,
                                UnitID:         item.UnitID,
                                Notes:          "Inventory Count Adjustment",
                                CreatedBy:      input.ApprovedBy,
                        }

                        uc.stockRepo.AdjustStock(ctx, stock, item.Variance, movement)</span>
                }
        }

        <span class="cov0" title="0">count.Complete(input.ApprovedBy)
        if err := uc.countRepo.Update(ctx, count); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// GetInventoryCountUseCase handles getting inventory count
type GetInventoryCountUseCase struct {
        countRepo repository.InventoryCountRepository
}

// NewGetInventoryCountUseCase creates a new use case
func NewGetInventoryCountUseCase(countRepo repository.InventoryCountRepository) *GetInventoryCountUseCase <span class="cov0" title="0">{
        return &amp;GetInventoryCountUseCase{countRepo: countRepo}
}</span>

// Execute gets inventory count by ID
func (uc *GetInventoryCountUseCase) Execute(ctx context.Context, id uuid.UUID) (*entity.InventoryCount, error) <span class="cov0" title="0">{
        return uc.countRepo.GetByID(ctx, id)
}</span>

// ListInventoryCountsUseCase handles listing inventory counts
type ListInventoryCountsUseCase struct {
        countRepo repository.InventoryCountRepository
}

// NewListInventoryCountsUseCase creates a new use case
func NewListInventoryCountsUseCase(countRepo repository.InventoryCountRepository) *ListInventoryCountsUseCase <span class="cov0" title="0">{
        return &amp;ListInventoryCountsUseCase{countRepo: countRepo}
}</span>

// Execute lists inventory counts
func (uc *ListInventoryCountsUseCase) Execute(ctx context.Context, filter *repository.InventoryCountFilter) ([]*entity.InventoryCount, int64, error) <span class="cov0" title="0">{
        return uc.countRepo.List(ctx, filter)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package issue

import (
        "context"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/erp-cosmetics/wms-service/internal/infrastructure/event"
        "github.com/google/uuid"
)

// EventPublisher defines event publishing interface for issue
type EventPublisher interface {
        PublishStockIssued(event *event.StockIssuedEvent) error
}

// CreateGoodsIssueUseCase handles goods issue creation with FEFO
type CreateGoodsIssueUseCase struct {
        issueRepo repository.GoodsIssueRepository
        stockRepo repository.StockRepository
        eventPub  EventPublisher
}

// NewCreateGoodsIssueUseCase creates a new use case
func NewCreateGoodsIssueUseCase(
        issueRepo repository.GoodsIssueRepository,
        stockRepo repository.StockRepository,
        eventPub EventPublisher,
) *CreateGoodsIssueUseCase <span class="cov8" title="1">{
        return &amp;CreateGoodsIssueUseCase{
                issueRepo: issueRepo,
                stockRepo: stockRepo,
                eventPub:  eventPub,
        }
}</span>

// CreateGoodsIssueInput represents input for creating goods issue
type CreateGoodsIssueInput struct {
        IssueDate       time.Time
        IssueType       entity.IssueType
        ReferenceType   entity.ReferenceType
        ReferenceID     *uuid.UUID
        ReferenceNumber string
        WarehouseID     uuid.UUID
        Notes           string
        IssuedBy        uuid.UUID
        Items           []CreateGoodsIssueItemInput
}

// CreateGoodsIssueItemInput represents an item to issue
type CreateGoodsIssueItemInput struct {
        MaterialID uuid.UUID
        Quantity   float64
        UnitID     uuid.UUID
}

// CreateGoodsIssueOutput represents output from goods issue
type CreateGoodsIssueOutput struct {
        ID          uuid.UUID
        IssueNumber string
        Status      string
        LineItems   []GoodsIssueLineItemOutput
}

// GoodsIssueLineItemOutput represents issued line item with FEFO details
type GoodsIssueLineItemOutput struct {
        LineNumber  int
        MaterialID  uuid.UUID
        IssuedQty   float64
        LotsUsed    []entity.LotIssued
}

// Execute creates goods issue using FEFO logic
func (uc *CreateGoodsIssueUseCase) Execute(ctx context.Context, input *CreateGoodsIssueInput) (*CreateGoodsIssueOutput, error) <span class="cov8" title="1">{
        // Generate issue number
        issueNumber, err := uc.issueRepo.GetNextIssueNumber(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create goods issue
        <span class="cov8" title="1">issue := &amp;entity.GoodsIssue{
                IssueNumber:     issueNumber,
                IssueDate:       input.IssueDate,
                IssueType:       input.IssueType,
                ReferenceType:   input.ReferenceType,
                ReferenceID:     input.ReferenceID,
                ReferenceNumber: input.ReferenceNumber,
                WarehouseID:     input.WarehouseID,
                Status:          entity.GoodsIssueStatusDraft,
                Notes:           input.Notes,
                IssuedBy:        &amp;input.IssuedBy,
        }

        if err := uc.issueRepo.Create(ctx, issue); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output := &amp;CreateGoodsIssueOutput{
                ID:          issue.ID,
                IssueNumber: issueNumber,
                Status:      string(issue.Status),
        }

        // Process each item with FEFO
        for i, item := range input.Items </span><span class="cov8" title="1">{
                // Issue using FEFO logic
                lotsIssued, err := uc.stockRepo.IssueStockFEFO(ctx, item.MaterialID, item.Quantity, input.IssuedBy)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // Create line item for each lot used
                <span class="cov8" title="1">lineNumber := i + 1
                for _, lotIssued := range lotsIssued </span><span class="cov8" title="1">{
                        lineItem := &amp;entity.GILineItem{
                                GoodsIssueID: issue.ID,
                                LineNumber:   lineNumber,
                                MaterialID:   item.MaterialID,
                                RequestedQty: item.Quantity,
                                IssuedQty:    lotIssued.Quantity,
                                UnitID:       item.UnitID,
                                LotID:        &amp;lotIssued.LotID,
                                LocationID:   &amp;lotIssued.LocationID,
                        }
                        if err := uc.issueRepo.CreateLineItem(ctx, lineItem); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // Create movement records
                <span class="cov8" title="1">movementNumber, _ := uc.stockRepo.GetNextMovementNumber(ctx, entity.MovementTypeOut)
                for _, lotIssued := range lotsIssued </span><span class="cov8" title="1">{
                        movement := entity.NewStockMovementOut(
                                item.MaterialID,
                                &amp;lotIssued.LotID,
                                &amp;lotIssued.LocationID,
                                item.UnitID,
                                input.IssuedBy,
                                lotIssued.Quantity,
                                entity.ReferenceTypeGI,
                                &amp;issue.ID,
                                movementNumber,
                        )
                        uc.stockRepo.CreateMovement(ctx, movement)
                }</span>

                <span class="cov8" title="1">output.LineItems = append(output.LineItems, GoodsIssueLineItemOutput{
                        LineNumber: lineNumber,
                        MaterialID: item.MaterialID,
                        IssuedQty:  item.Quantity,
                        LotsUsed:   lotsIssued,
                })

                // Publish event for each material issued
                lotsUsed := make([]event.LotUsedInIssue, len(lotsIssued))
                for j, lot := range lotsIssued </span><span class="cov8" title="1">{
                        lotsUsed[j] = event.LotUsedInIssue{
                                LotID:      lot.LotID.String(),
                                LotNumber:  lot.LotNumber,
                                Quantity:   lot.Quantity,
                                ExpiryDate: lot.ExpiryDate.Format("2006-01-02"),
                        }
                }</span>

                <span class="cov8" title="1">refID := ""
                if input.ReferenceID != nil </span><span class="cov0" title="0">{
                        refID = input.ReferenceID.String()
                }</span>
                <span class="cov8" title="1">uc.eventPub.PublishStockIssued(&amp;event.StockIssuedEvent{
                        MaterialID:    item.MaterialID.String(),
                        Quantity:      item.Quantity,
                        LotsUsed:      lotsUsed,
                        ReferenceType: string(input.ReferenceType),
                        ReferenceID:   refID,
                })</span>
        }

        // Mark issue as completed
        <span class="cov8" title="1">issue.Complete()
        uc.issueRepo.Update(ctx, issue)
        output.Status = string(entity.GoodsIssueStatusCompleted)

        return output, nil</span>
}

// GetGoodsIssueUseCase handles getting goods issue
type GetGoodsIssueUseCase struct {
        issueRepo repository.GoodsIssueRepository
}

// NewGetGoodsIssueUseCase creates a new use case
func NewGetGoodsIssueUseCase(issueRepo repository.GoodsIssueRepository) *GetGoodsIssueUseCase <span class="cov0" title="0">{
        return &amp;GetGoodsIssueUseCase{issueRepo: issueRepo}
}</span>

// Execute gets goods issue by ID
func (uc *GetGoodsIssueUseCase) Execute(ctx context.Context, id uuid.UUID) (*entity.GoodsIssue, error) <span class="cov0" title="0">{
        return uc.issueRepo.GetByID(ctx, id)
}</span>

// ListGoodsIssuesUseCase handles listing goods issues
type ListGoodsIssuesUseCase struct {
        issueRepo repository.GoodsIssueRepository
}

// NewListGoodsIssuesUseCase creates a new use case
func NewListGoodsIssuesUseCase(issueRepo repository.GoodsIssueRepository) *ListGoodsIssuesUseCase <span class="cov0" title="0">{
        return &amp;ListGoodsIssuesUseCase{issueRepo: issueRepo}
}</span>

// Execute lists goods issues
func (uc *ListGoodsIssuesUseCase) Execute(ctx context.Context, filter *repository.GoodsIssueFilter) ([]*entity.GoodsIssue, int64, error) <span class="cov0" title="0">{
        return uc.issueRepo.List(ctx, filter)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package lot

import (
        "context"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/google/uuid"
)

// GetLotUseCase handles getting lot
type GetLotUseCase struct {
        lotRepo repository.LotRepository
}

// NewGetLotUseCase creates a new use case
func NewGetLotUseCase(lotRepo repository.LotRepository) *GetLotUseCase <span class="cov0" title="0">{
        return &amp;GetLotUseCase{lotRepo: lotRepo}
}</span>

// Execute gets a lot by ID
func (uc *GetLotUseCase) Execute(ctx context.Context, id uuid.UUID) (*entity.Lot, error) <span class="cov0" title="0">{
        return uc.lotRepo.GetByID(ctx, id)
}</span>

// ListLotsUseCase handles listing lots
type ListLotsUseCase struct {
        lotRepo repository.LotRepository
}

// NewListLotsUseCase creates a new use case
func NewListLotsUseCase(lotRepo repository.LotRepository) *ListLotsUseCase <span class="cov0" title="0">{
        return &amp;ListLotsUseCase{lotRepo: lotRepo}
}</span>

// Execute lists lots
func (uc *ListLotsUseCase) Execute(ctx context.Context, filter *repository.LotFilter) ([]*entity.Lot, int64, error) <span class="cov0" title="0">{
        return uc.lotRepo.List(ctx, filter)
}</span>

// GetExpiringLotsUseCase handles getting expiring lots
type GetExpiringLotsUseCase struct {
        lotRepo repository.LotRepository
}

// NewGetExpiringLotsUseCase creates a new use case
func NewGetExpiringLotsUseCase(lotRepo repository.LotRepository) *GetExpiringLotsUseCase <span class="cov0" title="0">{
        return &amp;GetExpiringLotsUseCase{lotRepo: lotRepo}
}</span>

// Execute gets lots expiring within days
func (uc *GetExpiringLotsUseCase) Execute(ctx context.Context, days int) ([]*entity.Lot, error) <span class="cov0" title="0">{
        return uc.lotRepo.GetExpiringLots(ctx, days)
}</span>

// GetLotMovementsUseCase handles getting lot movements
type GetLotMovementsUseCase struct {
        stockRepo repository.StockRepository
}

// NewGetLotMovementsUseCase creates a new use case
func NewGetLotMovementsUseCase(stockRepo repository.StockRepository) *GetLotMovementsUseCase <span class="cov0" title="0">{
        return &amp;GetLotMovementsUseCase{stockRepo: stockRepo}
}</span>

// Execute gets movements for a lot
func (uc *GetLotMovementsUseCase) Execute(ctx context.Context, lotID uuid.UUID) ([]*entity.StockMovement, error) <span class="cov0" title="0">{
        return uc.stockRepo.GetMovementsByLot(ctx, lotID)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package reservation

import (
        "context"
        "time"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/erp-cosmetics/wms-service/internal/infrastructure/event"
        "github.com/google/uuid"
)

// EventPublisher defines event publishing interface for reservation
type EventPublisher interface {
        PublishStockReserved(event *event.StockReservedEvent) error
}

// CreateReservationUseCase handles stock reservation
type CreateReservationUseCase struct {
        stockRepo repository.StockRepository
        eventPub  EventPublisher
}

// NewCreateReservationUseCase creates a new use case
func NewCreateReservationUseCase(stockRepo repository.StockRepository, eventPub EventPublisher) *CreateReservationUseCase <span class="cov8" title="1">{
        return &amp;CreateReservationUseCase{
                stockRepo: stockRepo,
                eventPub:  eventPub,
        }
}</span>

// CreateReservationInput represents input for creating reservation
type CreateReservationInput struct {
        MaterialID      uuid.UUID
        Quantity        float64
        UnitID          uuid.UUID
        ReservationType entity.ReservationType
        ReferenceID     uuid.UUID
        ReferenceNumber string
        ExpiresAt       *time.Time
        CreatedBy       uuid.UUID
}

// Execute creates a stock reservation
func (uc *CreateReservationUseCase) Execute(ctx context.Context, input *CreateReservationInput) (*entity.StockReservation, error) <span class="cov8" title="1">{
        reservation := &amp;entity.StockReservation{
                MaterialID:      input.MaterialID,
                Quantity:        input.Quantity,
                UnitID:          input.UnitID,
                ReservationType: input.ReservationType,
                ReferenceID:     input.ReferenceID,
                ReferenceNumber: input.ReferenceNumber,
                Status:          entity.ReservationStatusActive,
                ExpiresAt:       input.ExpiresAt,
                CreatedBy:       input.CreatedBy,
        }

        if err := uc.stockRepo.ReserveStock(ctx, input.MaterialID, input.Quantity, reservation); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Publish event
        <span class="cov8" title="1">uc.eventPub.PublishStockReserved(&amp;event.StockReservedEvent{
                ReservationID:   reservation.ID.String(),
                MaterialID:      input.MaterialID.String(),
                Quantity:        input.Quantity,
                ReservationType: string(input.ReservationType),
                ReferenceID:     input.ReferenceID.String(),
        })

        return reservation, nil</span>
}

// ReleaseReservationUseCase handles releasing reservations
type ReleaseReservationUseCase struct {
        stockRepo repository.StockRepository
}

// NewReleaseReservationUseCase creates a new use case
func NewReleaseReservationUseCase(stockRepo repository.StockRepository) *ReleaseReservationUseCase <span class="cov8" title="1">{
        return &amp;ReleaseReservationUseCase{stockRepo: stockRepo}
}</span>

// Execute releases a reservation
func (uc *ReleaseReservationUseCase) Execute(ctx context.Context, reservationID uuid.UUID) error <span class="cov8" title="1">{
        return uc.stockRepo.ReleaseReservation(ctx, reservationID)
}</span>

// CheckAvailabilityUseCase checks stock availability
type CheckAvailabilityUseCase struct {
        stockRepo repository.StockRepository
}

// NewCheckAvailabilityUseCase creates a new use case
func NewCheckAvailabilityUseCase(stockRepo repository.StockRepository) *CheckAvailabilityUseCase <span class="cov0" title="0">{
        return &amp;CheckAvailabilityUseCase{stockRepo: stockRepo}
}</span>

// AvailabilityResult represents stock availability result
type AvailabilityResult struct {
        MaterialID     uuid.UUID
        TotalQuantity  float64
        ReservedQty    float64
        AvailableQty   float64
        IsAvailable    bool
        RequestedQty   float64
        ShortageQty    float64
        ExpiringInDays int
}

// Execute checks if material is available
func (uc *CheckAvailabilityUseCase) Execute(ctx context.Context, materialID uuid.UUID, requestedQty float64) (*AvailabilityResult, error) <span class="cov0" title="0">{
        summary, err := uc.stockRepo.GetMaterialSummary(ctx, materialID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := &amp;AvailabilityResult{
                MaterialID:    materialID,
                TotalQuantity: summary.TotalQuantity,
                ReservedQty:   summary.TotalReserved,
                AvailableQty:  summary.TotalAvailable,
                RequestedQty:  requestedQty,
                IsAvailable:   summary.TotalAvailable &gt;= requestedQty,
        }

        if !result.IsAvailable </span><span class="cov0" title="0">{
                result.ShortageQty = requestedQty - summary.TotalAvailable
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package stock

import (
        "context"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/erp-cosmetics/wms-service/internal/infrastructure/event"
        "github.com/google/uuid"
)

// GetStockUseCase handles stock queries
type GetStockUseCase struct {
        stockRepo repository.StockRepository
}

// NewGetStockUseCase creates a new use case
func NewGetStockUseCase(stockRepo repository.StockRepository) *GetStockUseCase <span class="cov0" title="0">{
        return &amp;GetStockUseCase{stockRepo: stockRepo}
}</span>

// Execute returns stock list
func (uc *GetStockUseCase) Execute(ctx context.Context, filter *repository.StockFilter) ([]*entity.Stock, int64, error) <span class="cov0" title="0">{
        return uc.stockRepo.List(ctx, filter)
}</span>

// GetByMaterial returns stock by material
func (uc *GetStockUseCase) GetByMaterial(ctx context.Context, materialID uuid.UUID) ([]*entity.Stock, error) <span class="cov0" title="0">{
        return uc.stockRepo.GetByMaterial(ctx, materialID)
}</span>

// GetSummary returns stock summary for a material
func (uc *GetStockUseCase) GetSummary(ctx context.Context, materialID uuid.UUID) (*entity.StockSummary, error) <span class="cov0" title="0">{
        return uc.stockRepo.GetMaterialSummary(ctx, materialID)
}</span>

// GetExpiringStock returns stock expiring within days
func (uc *GetStockUseCase) GetExpiringStock(ctx context.Context, days int) ([]*entity.Stock, error) <span class="cov0" title="0">{
        return uc.stockRepo.GetExpiringStock(ctx, days)
}</span>

// GetLowStock returns materials with low stock
func (uc *GetStockUseCase) GetLowStock(ctx context.Context, threshold float64) ([]*entity.StockSummary, error) <span class="cov0" title="0">{
        return uc.stockRepo.GetLowStockMaterials(ctx, threshold)
}</span>

// IssueStockFEFOUseCase handles issuing stock with FEFO logic
type IssueStockFEFOUseCase struct {
        stockRepo   repository.StockRepository
        eventPub    *event.Publisher
}

// NewIssueStockFEFOUseCase creates a new use case
func NewIssueStockFEFOUseCase(stockRepo repository.StockRepository, eventPub *event.Publisher) *IssueStockFEFOUseCase <span class="cov0" title="0">{
        return &amp;IssueStockFEFOUseCase{
                stockRepo:  stockRepo,
                eventPub:   eventPub,
        }
}</span>

// IssueStockInput represents input for issuing stock
type IssueStockInput struct {
        MaterialID      uuid.UUID
        Quantity        float64
        UnitID          uuid.UUID
        ReferenceType   entity.ReferenceType
        ReferenceID     *uuid.UUID
        ReferenceNumber string
        CreatedBy       uuid.UUID
}

// IssueStockOutput represents output from issuing stock
type IssueStockOutput struct {
        MovementNumber string
        LotsIssued     []entity.LotIssued
}

// Execute issues stock using FEFO logic
func (uc *IssueStockFEFOUseCase) Execute(ctx context.Context, input *IssueStockInput) (*IssueStockOutput, error) <span class="cov0" title="0">{
        // Issue using FEFO (First Expired First Out)
        lotsIssued, err := uc.stockRepo.IssueStockFEFO(ctx, input.MaterialID, input.Quantity, input.CreatedBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get movement number
        <span class="cov0" title="0">movementNumber, err := uc.stockRepo.GetNextMovementNumber(ctx, entity.MovementTypeOut)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create movement records for each lot
        <span class="cov0" title="0">for _, lot := range lotsIssued </span><span class="cov0" title="0">{
                movement := entity.NewStockMovementOut(
                        input.MaterialID,
                        &amp;lot.LotID,
                        &amp;lot.LocationID,
                        input.UnitID,
                        input.CreatedBy,
                        lot.Quantity,
                        input.ReferenceType,
                        input.ReferenceID,
                        movementNumber,
                )
                if err := uc.stockRepo.CreateMovement(ctx, movement); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Publish event
        <span class="cov0" title="0">lotsUsed := make([]event.LotUsedInIssue, len(lotsIssued))
        for i, lot := range lotsIssued </span><span class="cov0" title="0">{
                lotsUsed[i] = event.LotUsedInIssue{
                        LotID:      lot.LotID.String(),
                        LotNumber:  lot.LotNumber,
                        Quantity:   lot.Quantity,
                        ExpiryDate: lot.ExpiryDate.Format("2006-01-02"),
                }
        }</span>

        <span class="cov0" title="0">refID := ""
        if input.ReferenceID != nil </span><span class="cov0" title="0">{
                refID = input.ReferenceID.String()
        }</span>
        
        <span class="cov0" title="0">uc.eventPub.PublishStockIssued(&amp;event.StockIssuedEvent{
                MaterialID:    input.MaterialID.String(),
                Quantity:      input.Quantity,
                LotsUsed:      lotsUsed,
                ReferenceType: string(input.ReferenceType),
                ReferenceID:   refID,
        })

        return &amp;IssueStockOutput{
                MovementNumber: movementNumber,
                LotsIssued:     lotsIssued,
        }, nil</span>
}

// ReserveStockUseCase handles stock reservation
type ReserveStockUseCase struct {
        stockRepo repository.StockRepository
        eventPub  *event.Publisher
}

// NewReserveStockUseCase creates a new use case
func NewReserveStockUseCase(stockRepo repository.StockRepository, eventPub *event.Publisher) *ReserveStockUseCase <span class="cov0" title="0">{
        return &amp;ReserveStockUseCase{
                stockRepo: stockRepo,
                eventPub:  eventPub,
        }
}</span>

// ReserveStockInput represents input for reserving stock
type ReserveStockInput struct {
        MaterialID      uuid.UUID
        Quantity        float64
        UnitID          uuid.UUID
        ReservationType entity.ReservationType
        ReferenceID     uuid.UUID
        ReferenceNumber string
        CreatedBy       uuid.UUID
}

// Execute reserves stock
func (uc *ReserveStockUseCase) Execute(ctx context.Context, input *ReserveStockInput) (*entity.StockReservation, error) <span class="cov0" title="0">{
        reservation := &amp;entity.StockReservation{
                MaterialID:      input.MaterialID,
                Quantity:        input.Quantity,
                UnitID:          input.UnitID,
                ReservationType: input.ReservationType,
                ReferenceID:     input.ReferenceID,
                ReferenceNumber: input.ReferenceNumber,
                Status:          entity.ReservationStatusActive,
                CreatedBy:       input.CreatedBy,
        }

        if err := uc.stockRepo.ReserveStock(ctx, input.MaterialID, input.Quantity, reservation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Publish event
        <span class="cov0" title="0">uc.eventPub.PublishStockReserved(&amp;event.StockReservedEvent{
                ReservationID:   reservation.ID.String(),
                MaterialID:      input.MaterialID.String(),
                Quantity:        input.Quantity,
                ReservationType: string(input.ReservationType),
                ReferenceID:     input.ReferenceID.String(),
        })

        return reservation, nil</span>
}

// ReleaseReservationUseCase handles releasing reservations
type ReleaseReservationUseCase struct {
        stockRepo repository.StockRepository
}

// NewReleaseReservationUseCase creates a new use case
func NewReleaseReservationUseCase(stockRepo repository.StockRepository) *ReleaseReservationUseCase <span class="cov0" title="0">{
        return &amp;ReleaseReservationUseCase{stockRepo: stockRepo}
}</span>

// Execute releases a reservation
func (uc *ReleaseReservationUseCase) Execute(ctx context.Context, reservationID uuid.UUID) error <span class="cov0" title="0">{
        return uc.stockRepo.ReleaseReservation(ctx, reservationID)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package warehouse

import (
        "context"

        "github.com/erp-cosmetics/wms-service/internal/domain/entity"
        "github.com/erp-cosmetics/wms-service/internal/domain/repository"
        "github.com/google/uuid"
)

// ListWarehousesUseCase handles listing warehouses
type ListWarehousesUseCase struct {
        warehouseRepo repository.WarehouseRepository
}

// NewListWarehousesUseCase creates a new use case
func NewListWarehousesUseCase(warehouseRepo repository.WarehouseRepository) *ListWarehousesUseCase <span class="cov0" title="0">{
        return &amp;ListWarehousesUseCase{warehouseRepo: warehouseRepo}
}</span>

// Execute lists warehouses
func (uc *ListWarehousesUseCase) Execute(ctx context.Context, filter *repository.WarehouseFilter) ([]*entity.Warehouse, int64, error) <span class="cov0" title="0">{
        return uc.warehouseRepo.List(ctx, filter)
}</span>

// GetWarehouseUseCase handles getting warehouse
type GetWarehouseUseCase struct {
        warehouseRepo repository.WarehouseRepository
}

// NewGetWarehouseUseCase creates a new use case
func NewGetWarehouseUseCase(warehouseRepo repository.WarehouseRepository) *GetWarehouseUseCase <span class="cov0" title="0">{
        return &amp;GetWarehouseUseCase{warehouseRepo: warehouseRepo}
}</span>

// Execute gets a warehouse by ID
func (uc *GetWarehouseUseCase) Execute(ctx context.Context, id uuid.UUID) (*entity.Warehouse, error) <span class="cov0" title="0">{
        return uc.warehouseRepo.GetByID(ctx, id)
}</span>

// GetZonesUseCase handles getting zones for a warehouse
type GetZonesUseCase struct {
        zoneRepo repository.ZoneRepository
}

// NewGetZonesUseCase creates a new use case
func NewGetZonesUseCase(zoneRepo repository.ZoneRepository) *GetZonesUseCase <span class="cov0" title="0">{
        return &amp;GetZonesUseCase{zoneRepo: zoneRepo}
}</span>

// Execute gets zones for a warehouse
func (uc *GetZonesUseCase) Execute(ctx context.Context, warehouseID uuid.UUID) ([]*entity.Zone, error) <span class="cov0" title="0">{
        return uc.zoneRepo.GetByWarehouseID(ctx, warehouseID)
}</span>

// GetLocationsUseCase handles getting locations for a zone
type GetLocationsUseCase struct {
        locationRepo repository.LocationRepository
}

// NewGetLocationsUseCase creates a new use case
func NewGetLocationsUseCase(locationRepo repository.LocationRepository) *GetLocationsUseCase <span class="cov0" title="0">{
        return &amp;GetLocationsUseCase{locationRepo: locationRepo}
}</span>

// Execute gets locations for a zone
func (uc *GetLocationsUseCase) Execute(ctx context.Context, zoneID uuid.UUID) ([]*entity.Location, error) <span class="cov0" title="0">{
        return uc.locationRepo.GetByZoneID(ctx, zoneID)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
